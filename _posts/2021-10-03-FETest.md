---
title: Jest, Cypress로 FE를 테스트해보자[1편]
author: Sanghun lee
date: 2021-10-03 11:33:00 +0800
categories: [Blogging, Jest, FE Test, Cypress]
tags: [Jest, FE Test, Cypress, msw]
math: true
mermaid: true
image:
  src: https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcZDedj%2FbtraJzj53sn%2FHdUj1jQOUihHUy0oday6kK%2Fimg.png
  width: 850
  height: 585
---

# 시작하게 된 이유

사내에서 앱의 크기가 방대해지며 전체적인 구조를 비즈니스로직과 뷰로 나누는 작업을 진행하였다.

이 과정에서 상수, 반복문, interface등의 타입정의를 나눴고 적지 않은 변화가 발생하며 기존에 잘 작동하던 코드가 실제로 원하는 방식으로 작동하는지 확인해보기 위한 검증이 필요하였다.

그래서 그 기회를 통해 FE테스트를 도입해보자! 라는 패기로운 생각과 함께 여러가지 자료를 찾으며 삽질을 하였고..

정화된 결과를 정리하는 글을 써보자 생각하여 글을작성한다.

# 1. 개념 (Unit, Integration, E2E)

사실 처음 시작할때는 Jest라이브러리의 존재말고는 친숙하지 않아 개념을 잡는것에 많이 해맸었다.
백엔드의 테스트 같은 경우 req, res로 요청과 응답이 일정한 반면 프론트의 경우 유저 이벤트 -> 이벤트 발생 -> 화면변경으로
연결되거나 그 사이에 데이터 호출또한 담겨 있을 수 있기떄문에 명확한 기준을 설정해야했다.

특히 프론트단에서의 Unit테스트와 Integration Test의 범위를 어떤방식으로 나뉘어야 효과적일지에 대해 고민이 많이 들었고
[2019-실용적인프론트엔드 테스트 전략](https://www.youtube.com/watch?v=q9d631Nl0_4)를 통해 각 테스트의 경계부분을 설정하는 것에 많은 도움이 되었다.

현재 재직하고 있는 회사의 Tech Stack은 react, redux-toolkit, redux-saga, styled-component로 프론트가 구성되어있고

각 API, constant, util들은 분리가 되어 있으며 페이지 마다 그 분기를 가져가고 있다.

## 1.1 Unit Test

가장 간단한 단위로서 현재 회사의 TechStack 중 redux-toolkit에 존재하는 로직 및 복잡한 util 함수에 한해서 매우 복잡도가 높은 경우만 해당 테스트를 진행하기로 했다.

이렇게 정한 이유는 애초부터 test coverage를 높이는 것이 목적이 아닌 경력이 짧은 개발자들로 구성된 팀에서 최소한의 방어장치를 위해 접목한 것이기 때문이다.

쉽게 말하면 실수 방지장치의 목적이 크기때문에 제일 최소한의 안전장치만 진행하였다.

```javascript
describe("근무유형등록 > 고정형 > Select option 조건에 따라 state변경", () => {
  afterEach(() => {
    reducer(initialState, initialSetting());
  });

  describe("handleFixAttendStartTime", () => {
    test("시간타입 변경 시 퇴근시간은 시작시간 + 9로 변경됨", () => {
      expect(
        reducer(
          initialState,
          handleFixAttendStartTime({ timeType: "hour", value: "10" })
        )
      ).toEqual({ ...initialState, attendTime: "1000", leaveTime: "1900" });
    });

    test("분 타입 변경 시 출근시간과 동일한 분을 가지게 됨(00분 또는 30분)", () => {
      expect(
        reducer(
          { ...initialState },
          handleFixAttendStartTime({ timeType: "minute", value: "30" })
        )
      ).toEqual({ ...initialState, attendTime: "0930", leaveTime: "1830" });
    });
  });
});
```

위 코드와 같이 해당하는 reducer, action creator를 가져와서 정해놓은 로직에 따라 기대한 state를 반환하는지 테스트 하였다.

afterEach를 사용하여 각 테스트가 진행되기 전 state값을 초기화 하여 상호 테스트 간에 영향이 없도록 만들었다.

util과 같은 간단한 함수도 유사한 방식으로 진행해줬다.

## 1.2 Integration Test

Integration Test는 초기에는 testing-library와 jest의 조합만 활용하여 DOM snapshot의 클래스명을 통해 이를 확인해볼까 생각을했다.

하지만 styled-component로 만들어지는 스타일 컴포넌트가 대부분이므로 클래스명으로 이를 판단하기에는 무리가 있었기 때문에 다른 방식이 필요했고

무엇보다 실제화면이 아닌 DOM만으로 이것이 정확하게 작동하고 있는지 판단하기에는 무리가 있다.

그래서 cypress를 통해 실제 UI의 변경사항을 보면서 테스팅을 가능한 방식으로 진행하였다.

API 호출의 경우 cypress에서 기본적으로 fixture를 활용하여 mocking-response를 반환해주는 메서드가 존재하나 실제 서버에 데이터를 전송하고 받아온 데이터를 모킹하는 방식이므로

비효율적이란 판단과 동시에 Integration Test보다는 E2E테스트와 유사하다고 보이기 때문에 실제 api request, response 모두를 모킹할 수 있는 라이브러리인 msw를 선택하여 사용하였다.

```javascript
  rest.get(`${VACATION_PREVIEW_URL}`, (req, res, ctx) => {
    const monthType = req.url.searchParams.get('monthType');
    const yearType = req.url.searchParams.get('yearType');
    const enterDate = req.url.searchParams.get('enterDate');

    let newdateData = [...dateData];
    const len = newdateData.length;
    if (monthType === 'BEFORE') {
      newdateData.splice(len - 1, 1, {
        ...dateData[len - 1],
        yearRemark: monthType === 'BEFORE' ? '1번째 회계일' : null,
        monthRemark: monthType === 'BEFORE' ? null : '4개월차',
      });
    }

    if (yearType) {
      newdateData.splice(0, 1, {
        ...dateData[0],
        yearRemark: yearType === 'ACCOUNT_FULL' ? '회계일' : '입사일',
      });
    }

    if (enterDate) {
      newdateData = newdateData.map((el, index) => ({
        ...el,
        date: `2021-${
          Number(newdateData[0].date.split('-')[1]) + index
        }-${String(enterDate).slice(-2)}`,
      }));
    }

    return res(ctx.json([...newdateData]));
  }),
```

> handler.ts

위 코드와 같이 조건등에 따라 마음대로 msw를 설정할 수 있고 실제로 요청을 하지 않으므로 완벽히 프론트 단에서 원하는 상황에 대한 테스트를 할 수 있게 된다.

```javascript
describe(() => {
  it("모달에 내용 변경 뒤 나가기 버튼 클릭 후 다시 열었을때 내용 초기화", () => {
    user.findAllByText("설정").click();

    user.findAllByText("입사자 월차").siblings().click();
    user.get("ul").find("li").contains("입사일에 11개 선 지급").click();
    user.findAllByText("입사일에 11개 선 지급").should("exist");

    user.findAllByText("나가기").click();

    user.findAllByText("설정").click();
    user.findAllByText("1달만근 시 1일 지급").should("exist");
  });
});
```

> sth.integration.ts

cypress의 경우 위에 작성된 방식처럼 특수하게 중복될 일 없는 텍스트를 통해서 테스트를 위한 dom에 접근하여 click이벤트 및 존재여부 확인등을 쉽게 판단할 수 있게 된다.

다만, 공식문서에는 그리 추천하지 않고 `data-id` 등을 통해서 테스트를 위한 아이디값을 미리 설정하고 확인하는것을 추천한다.

## 1.3 E2E Test

사실 integration test와 e2e테스트에서 차이점을 준 것은 백엔드와의 연동이 되느냐 마느냐의 문제로 나뉘었다.

프론트엔드 특성 하나의 유저 이벤트를 통해 다양한 API호출이 발생하고 화면이 변경되고 하는 일이 많아 페이지별로 integration test를 진행하고

모든 작동이 정상적으로 된다면 이벤트를 통해 API를 호출하는 등의 행동에 대한 안정성이 커버된다고 판단했기 때문이다.

또한, Timing-difference로 인해 호출되는 순서에 대한 확인이 필요하거나 호출 횟수가 의도한대로 발생하는지에 대해 확인하기 위해서는 별도로
`toHaveBeenCalled()` 와 같은 메서드를 통해 확인해주거나 실제 테스트가 진행되는 동안 모든 로그가 찍히기때문에 직접 확인해보는 방법이 있어 이를 활용하였다.

## 1.4 Redux-saga Unit Test

사실 테스트에 대해 거의 모르는 상황에서 테스트를 무작정해봐야겠다고 처음 시도했던 것이 redux-saga쪽이었다.

# 3. 결론

## 참고

- [Fetching Data at Request Time](https://nextjs.org/learn/basics/data-fetching/request-time)
- [getStaticProps Details](https://nextjs.org/learn/basics/data-fetching/getstaticprops-details)
