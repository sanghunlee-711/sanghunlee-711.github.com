---
title: webpack 기본[0]
author: Sanghun lee
date: 2021-09-12 11:33:00 +0800
categories: [Blogging, NestJs]
tags: [NestJs]
math: true
mermaid: true
image:
  src: https://nestjs.com/img/nest-og.png
  width: 850
  height: 585
---

# 왜 하게 되었냐면

## 서론

회사에서 기존 CRA로 만든 프로젝트를 커스텀엘리먼트화 하여 외부로 보내는 작업을 맡게 되었고, 아직 구체적인 기획안과 협의안이 나오지 않은 상태이나 일단 기본적으로 할 수 있는 방법을 알아야 하기 때문에 공부를 할 필요성이(드디어!!) 생겼다!

샘플을 만들며 webpack,babel,loader 등의 세부 세팅을 공부하며 정리해보겠다 :)

[공식문서](https://ko.reactjs.org/docs/create-a-new-react-app.html#more-flexible-toolchains)에 링크된 [툴체인 직접만들기](https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658)를 최대한 참고하며 다른 블로그들(최하단 참고 파트)도 보며 상황에 맞춰 세팅을 진행했다.

## Nest Js의 코어 개념

> 대부분 Nest Js공식문서의 말을 재 반복하는 내용이므로 관심없으신분들은 빠르게 이 파트를 스킵하시면 됩니다

일단 나는 RestAPI 방식이 아닌 graphql을 통해 진행하였기 때문에 @Get, @Post와 같은 데코레이터를 사용하지 않아도 되었다.

데코레이터는 클래스, 메서드 또는 속성에 대해 정의하는 기능을 하게 되며 nestjs에서 기본적으로 다양한 데코레이터를 제공해준다

이로 인해 개발속도가 폭발적으로 증가하게 되는 경험을 하였다 ㅋ..

크고 간단하게 몇가지 개념들만 설명하고 내가 구현한것들을 정리하면서 세세한 부분을 푸는게 좋을 것 같다.

크게 module, resolver, service라는 개념으로
각 모듈은 기본적으로 프로바이더를 캡슐화한다.

![nestjsofficial-module](https://docs.nestjs.kr/assets/Modules_1.png)
_module-concept_

그럼 프로바이더란 무엇이냐 Nest 인젝터에 의해 인스턴스화 되고 적어도 이 모듈에서 공유될 수 있는 것을 말하는 것이라고한다..

말로 설명하기 어려우니 간단한 샘플을 보며 설명을 하는 것이 좋을 것 같다.

```typescript
@Module({
  imports: [TypeOrmModule.forFeature([User, Verification])],
  providers: [UsersResolver, UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

_users.module.ts_

위는 `users.module.ts` 파일의 코드이다.

일단 `app.module.ts`(모든 모듈의 루트 모듈이라고 보면 된다-> TMI로 Nest js는 `싱글톤 패턴`을 가지고 있다)에서 `TypeOrmModule` 대한 정의를 내릴 때 entity에 user와 verification이 등록된 것을 가져오기 위해 imports메서드를 사용한 것을 볼 수 있다.

이로 인해 자연스럽게 유추할 수 있는것은 다른 모듈 또는 루트 모듈에 존재하는 것을 해당 모듈에서 사용하기 위해서는 그 모듈의 `imports 메서드`를 사용해야한다는 것이다.

그리고 `provider`는 위에서 언급하였듯 해당 모듈 내에서 공유될 수 있는 것들에 대한 정의를 내려주는 곳인데 userResolver와 userService가 있는 것을 볼 수 있다.

여기서 `resolver`의 역할은 GraphQL operation(query, mutation, subscription)을 데이터로 변환하기 위한 명령을 제공하기 위해 사용된다.
자세히 보면 graphql을 통해 어떠한 인자를 받을 것인지에 대한 정의가 되어있는 dto파일을 통해 인자를 받고 해당 로직이 완성된 후 return할 타입에 대한 정의가 되어있다.

추가로 이 로직이 Mutation인지 Query인지에 대한 정의도 한다.

```typescript
  @Role(['Any'])
  @Mutation(() => EditProfileOutput)
  async editProfile(
    @AuthUser() authUser: User,
    @Args('input') editProfileInput: EditProfileInput,
  ): Promise<EditProfileOutput> {
    return this.usersService.editProfile(authUser, editProfileInput);
  }
```

_users.resolver.ts 중 일부_

그리고 `service`의 역할은 해당 resolver가 실행시키고 싶은 비즈니스 로직 부분을 담당하게 된다.

아래 코드는 위의 `users.resolver.ts 중 일부`에서 return 시킨 서비스 로직이다.

```typescript
  async changeRole({ role, id }: ChangeRoleInput): Promise<ChangeRoleOutput> {
    try {
      const user = await this.users.findOne({ id });

      if (!user) {
        return {
          ok: false,
          error: '존재하지 않는 유저 입니다..',
        };
      }

      user.role = role;

      this.users.save(user);

      return {
        ok: true,
      };
    } catch {
      return {
        ok: false,
        error: '알 수 없는 이유로 권한변경에 실패하였습니다.',
      };
    }
  }
```

_users.service.ts 중 일부_

이렇게 큰 틀에서 보면 여러개의 module+resolver+service의 합이 app.module에서 합쳐져 안전하게 운영될 수 있게 된다.

위에서 보이는 @Args('input)이나 @Role()데코레이터는 자세한 구현사항을 설명하며 함께 이야기 해보겠다 :)

일단 기본적인 틀에 대한 개념은 아주 간략하게 설명이 된 것 같다.

> PS. 해당 user단의 구성방식은 [(풀스택) 우버 이츠 클론코딩](https://nomadcoders.co/nuber-eats/lobby)의 강의에서 나오는 방식과 매우 유사하게 진행되었다.

> 추가적으로 내가 만들고 싶은 서비스(커뮤니티)에 필요한 몇개의 mutation과 query들만 추가 되는 내용으로 설명이 될 것이므로 해당 강의를 보신분은 빠르게 강의를 다시보시는 것도 추천한다 ㅎㅅㅎ..

## 참고

- [자주 사용하는 로더-웹팩(Webpack) 기본편|김정환](https://agal.tistory.com/68)
