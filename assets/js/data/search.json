[ { "title": "리액트에서 비즈니스 로직을 나눠보자[3 - ContextAPI마저 활용해보자]", "url": "/posts/refactoring-3/", "categories": "FE, React", "tags": "Architecture", "date": "2022-05-12 12:33:00 +0900", "snippet": "Props Drilling을 피해보기2편의 hooks의 방식으로 state(상태)를 로컬에서 계속 가져가기를 바라면 대부분 페이지의 최상단에서 하단의 매칭된 컴포넌트까지 Props Drilling이 생기게 된다.아래 예제를 한번 봐보자.무엇이 문제였는가?일단 공용으로 사용되는 컴포넌트를 한번 봐보자.아래는 기간을 정할 수 있기 위해 사용하는 컴포넌트로 날짜와 시간을 정할 수 있는 컴포넌트이다.interface IPeriodSelectorProps { withTimes: boolean; labelText?: string; date: [Date, Date]; selectTime: string[]; handleStartDate: (date: Date) =&amp;gt; void; handleEndDate: (date: Date) =&amp;gt; void;}const PeriodSelector: React.FC&amp;lt;IPeriodSelectorProps&amp;gt; = ({ withTimes, labelText, date, selectTime, handleStartDate, handleEndDate,}): JSX.Element =&amp;gt; { return ( &amp;lt;WrapperDate&amp;gt; &amp;lt;span&amp;gt;{labelText || &quot;기간 선택&quot;}&amp;lt;/span&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;Calendar date={date[0] || new Date()} handleDate={handleStartDate || (() =&amp;gt; null)} /&amp;gt; {withTimes &amp;amp;&amp;amp; handleTime &amp;amp;&amp;amp; selectTime &amp;amp;&amp;amp; ( &amp;lt;input type=&quot;time&quot; value={selectTime &amp;amp;&amp;amp; selectTime[0]} name=&quot;startTime&quot; onChange={handleTime} /&amp;gt; )} &amp;lt;/div&amp;gt; &amp;lt;span&amp;gt;~&amp;lt;/span&amp;gt; &amp;lt;div&amp;gt; &amp;lt;Calendar date={date[1] || new Date()} handleDate={handleEndDate || (() =&amp;gt; null)} /&amp;gt; {withTimes &amp;amp;&amp;amp; handleTime &amp;amp;&amp;amp; selectTime &amp;amp;&amp;amp; ( &amp;lt;input type=&quot;time&quot; value={selectTime &amp;amp;&amp;amp; selectTime[1]} name=&quot;endTime&quot; onChange={handleTime} /&amp;gt; )} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/WrapperDate&amp;gt; );};const areEqual = ( prevProps: Readonly&amp;lt;PropsWithChildren&amp;lt;IPeriodSelectorProps&amp;gt;&amp;gt;, nextProps: Readonly&amp;lt;PropsWithChildren&amp;lt;IPeriodSelectorProps&amp;gt;&amp;gt;) =&amp;gt; { return ( prevProps.date === nextProps.date || prevProps.selectTime === nextProps.selectTime || prevProps.labelText === nextProps.labelText );};export default React.memo(PeriodSelector, areEqual);그래도 렌더링 최적화를 애쓰려고 memoizing을 해놓은것이 참..일단 해당컴포넌트만을 바라보았을때는 Props 개수가 다소 많지만 그래도 용인할 수 있는 수준인 것 같다고 생각하며개발을 계속 진행할 수 있다.하지만 이 컴포넌트를 사용하는 입장의 각 페이지별 index페이지를 보면 이야기가 달라진다....생략import usePeriodSelector from &#39;hooks/usePeriodSelector&#39;;...생략export const BannerList: React.FC = (): JSX.Element =&amp;gt; { ...생략 const { state: { date }, actions: { handleEndDate, handleStartDate, initializeDate }, } = usePeriodSelector(); ...생략 return ( &amp;lt;&amp;gt; &amp;lt;BannerListPageSelectors checkArr={checkArr} date={date} title={title} register={register} bannerType={bannerType} isSearching={isSearching} onSearch={onSearch} onCancelSearch={initializeSearchData} handleStatus={handleStatus} handleInput={handleInput} handleSelect={handleSelect} handleEndDate={handleEndDate} handleStartDate={handleStartDate} /&amp;gt; &amp;lt;BannerListTableList data={listData || []} total={totalDataCount || 0} doRefetch={doRefetch} /&amp;gt; &amp;lt;/&amp;gt; );};해당 코드는 배너목록을 보여주며 검색을 위한 검색창이 상단에 있고 아래는 테이블이 있는 UI를 가진 페이지의 index파일이다.일부 코드만을 가져왔음에도 불구하고 BannerListPageSelectors컴포넌트의 Props갯수를 보면 숨이 막힌다.그럼 BannerListPageSelectors의 코드를 보자....생략interface IBannerListPageSelectorsProps { ...생략 date: [Date, Date]; handleEndDate: (endDate: Date) =&amp;gt; void; handleStartDate: (startDate: Date) =&amp;gt; void; ...생략}export const BannerListPageSelectors: React.FC&amp;lt; IBannerListPageSelectorsProps&amp;gt; = ({ ...생략 date, handleEndDate, handleStartDate, ...생략}): JSX.Element =&amp;gt; { ...생략 ...생략 return ( &amp;lt;BasicSelectorContainer onSearch={onSearch} isSearching={isSearching} onCancelSearch={onCancelSearch} &amp;gt; &amp;lt;PageSelectWrapper&amp;gt; &amp;lt;DefaultPageSelect label=&quot;배너 유형&quot; selectOptions={bannerListData} selectValue={bannerType.value} onSelect={handleSelect} selectWidth=&quot;470px&quot; selectHeight=&quot;45px&quot; fontSize=&quot;16px&quot; placeHolder=&quot;배너 유형을 선택해주세요.&quot; name=&quot;bannerType&quot; /&amp;gt; &amp;lt;PeriodSelector startDate={date[0]} endDate={date[1]} withTimes={false} handleEndDate={handleEndDate} handleStartDate={handleStartDate} /&amp;gt; ...생략 &amp;lt;/PageSelectWrapper&amp;gt; &amp;lt;/BasicSelectorContainer&amp;gt; );};Props의 전달만을 위한 Props전달이 보이는 코드인데 BannerListPageSelectors는usePeriodSelector 라는 훅에서 보내준 메서드와 상태 그 어느것도 사용하지 않는 것을 알 수 있으며오직 PeriodSelector라는 컴포넌트에 이것들을 넘기기 위해서만 값을 Props를 받고 있다.위 예제는 아주 단적인 예시인데 특정페이지에서는 의도치 않게 이것보다 뎁스가 깊어지는 경우도 있었다.모든 개발을 위와같은 특정 UI Component + hooks를 통해 로직의 재활용성을 높이는 방식으로 진행했기에 이와 같은 Props Drilling 현상은 개발을 하기에 여간 귀찮은것이 아니었다.그럼 마지막으로 PeriodSelector를 위한 로직이 구성된 별도의 훅까지 살펴보고 이를 어떻게 개선했는지를 살펴보자.import { PREV_MONTH, TODAY } from &quot;constant/dateConstants&quot;;import React, { useEffect, useState } from &quot;react&quot;;import { dateAndTimeAssemble } from &quot;utils/formatting&quot;;const usePeriodSelector = () =&amp;gt; { const [date, setDate] = useState&amp;lt;[Date, Date]&amp;gt;([PREV_MONTH, TODAY]); const [selectTime, setSelectTime] = useState([&quot;00:00&quot;, &quot;00:00&quot;]); const [assembleDate, setAssembleDate] = useState&amp;lt;[Date, Date]&amp;gt;([ new Date(), new Date(), ]); const handleStartDate = (startDate: Date) =&amp;gt; { setDate([startDate, date[1]]); }; const handleEndDate = (endDate: Date) =&amp;gt; { setDate([date[0], endDate]); }; const handleTime = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const { name, value } = e.currentTarget; if (name === &quot;startTime&quot;) { setSelectTime([value, selectTime[1]]); } if (name === &quot;endTime&quot;) { setSelectTime([selectTime[0], value]); } }; const initializeDate = () =&amp;gt; { setDate([PREV_MONTH, TODAY]); setSelectTime([&quot;00:00&quot;, &quot;00:00&quot;]); }; useEffect(() =&amp;gt; { const { startModifed, endModified } = dateAndTimeAssemble({ startDate: date[0], startTime: selectTime[0], endDate: date[1], endTime: selectTime[1], }); setAssembleDate([startModifed, endModified]); }, [date, selectTime]); return { state: { date, assembleDate, selectTime, }, actions: { setDate, setSelectTime, initializeDate, handleStartDate, handleEndDate, handleTime, }, };};export default usePeriodSelector;위와 같은 코드를 특정컴포넌트에 실행한 뒤 state와 actions를 빼와서 필요한용도로 사용할 수 있게 된다.이렇게 중복된 로직을 계속 활용해나가는 방식을 차용했다.그럼 이제 이 지옥같은 PropsDrilling을 ContextAPI와 함께 조금 더 우아하게 풀어보자.Context API를 적용하자1. hooks에 컨텍스트를 추가해보자import { PREV_MONTH, TODAY } from &#39;constant/dateConstants&#39;;import React, { createContext, useEffect, useState } from &#39;react&#39;;import { dateAndTimeAssemble } from &#39;utils/formatting&#39;;interface IPeriodContext { ...생략} //추가export const PeriodContext = createContext&amp;lt;IPeriodContext | undefined&amp;gt;( undefined,); //추가const usePeriodSelector = () =&amp;gt; { const [date, setDate] = useState&amp;lt;[Date, Date]&amp;gt;([PREV_MONTH, TODAY]); const [selectTime, setSelectTime] = useState([&#39;00:00&#39;, &#39;00:00&#39;]); ...생략 const state = { ...생략 date, }; const actions = { ...생략 handleStartDate, handleEndDate, handleTime, }; const periodContextValue = { state, actions }; //추가 return { state, actions, periodContextValue, };};export default usePeriodSelector;우선 createContext를 통해 PeriodContext를 만들어주고 해당하는 타입도 미리 만들어준다나는 위 코드와 같이 state와 actions을 그냥 한무더기에 모아 contextValue로 사용할 것이라는 네이밍을 한뒤 hooks의 리턴값에 하나 추가해주었다.이렇게 하면 추가된 부분은 총 3파트 정도된다2. 컨텍스트 Provider를 만들어주자...import usePeriodSelector, { PeriodContext } from &#39;hooks/usePeriodSelector&#39;;...export const BannerList: React.FC = (): JSX.Element =&amp;gt; { ... const { ... periodContextValue, } = usePeriodSelector(); ... return ( &amp;lt;&amp;gt; &amp;lt;PeriodContext.Provider value={periodContextValue}&amp;gt; &amp;lt;BannerListPageSelectors checkArr={checkArr} // date={date} title={title} register={register} bannerType={bannerType} isSearching={isSearching} onSearch={onSearch} onCancelSearch={initializeSearchData} handleStatus={handleStatus} handleInput={handleInput} handleSelect={handleSelect} // handleEndDate={handleEndDate} // handleStartDate={handleStartDate} /&amp;gt; &amp;lt;/PeriodContext.Provider&amp;gt; &amp;lt;BannerListTableList data={listData || []} total={totalDataCount || 0} doRefetch={doRefetch} /&amp;gt; &amp;lt;/&amp;gt; );};프로바이더를 만들어준 뒤 hooks에서 컨텍스트가 필요한 값을 빼와서 넣어준 것이다.사실 더 낮은단위에서 제공해줘도 되지만 usePeriodSelector에서 나온 state값을 검색을위한 API호출에도 별도로 사용해야 하므로 위와 같은 구조가 만들어져 있다.그리고 이제 어떻게 BannerListPageSelectors에서 기존에 있던 Props를 뺐는지 다른 변경된 코드도 한번 봐보자3. Hooks와 한쌍이었던 컴포넌트에 Context를 미리 심어놓자import Calendar from &quot;components/calendar&quot;;import { PeriodContext } from &quot;hooks/usePeriodSelector&quot;;import React, { useContext } from &quot;react&quot;;import { WrapperDate } from &quot;./styles&quot;;interface IPeriodSelectorProps { withTimes: boolean; labelText?: string;}const PeriodSelector: React.FC&amp;lt;IPeriodSelectorProps&amp;gt; = ({ withTimes, labelText,}): JSX.Element =&amp;gt; { const periodContext = useContext(PeriodContext); //여기 if (!periodContext?.state || !periodContext?.actions) throw new Error(&quot;Period Context를 주입해주세요&quot;); const { state: { date, selectTime }, actions: { handleStartDate, handleEndDate, handleTime }, } = periodContext; //여기 return ( &amp;lt;WrapperDate&amp;gt; &amp;lt;span&amp;gt;{labelText || &quot;기간 선택&quot;}&amp;lt;/span&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;Calendar date={date[0] || new Date()} handleDate={handleStartDate || (() =&amp;gt; null)} /&amp;gt; {withTimes &amp;amp;&amp;amp; handleTime &amp;amp;&amp;amp; selectTime &amp;amp;&amp;amp; ( &amp;lt;input type=&quot;time&quot; value={selectTime &amp;amp;&amp;amp; selectTime[0]} name=&quot;startTime&quot; onChange={handleTime} /&amp;gt; )} &amp;lt;/div&amp;gt; ... &amp;lt;/div&amp;gt; &amp;lt;/WrapperDate&amp;gt; );};export default PeriodSelector;이제 위와 같은 방식으로 Hooks파일에 선언해놓았던 Context를 불러와 에러핸들링을 한번해주고나머지 값들을 편안하게 사용할 수 있다.Props의 개수가 확연히 준것을 알 수 있다. 사실 여기까지는 문제가 되지 않았다.문제점렌더링에 대한 문제가 생긴다.ContextAPI는 Sugar Syntax와 비슷하게 실제로 코드상에서는 PropsDrilling을 하지 않지만 사실상 그와 같은 행위를 하고 있어 하나의 컨텍스트만 바뀌어도해당 컨텍스트를 참조하고 있는 모든 부분에서 리렌더링이 일어난다. 이는 아래와 같이 해결할 수 있다.Memoizing을 위한 컨테이너 만들기import { PeriodContext } from &quot;hooks/usePeriodSelector&quot;;import { useContext, useMemo } from &quot;react&quot;;interface IMemoizePeriodSelectorContainerProps { children: React.ReactNode;}const MemoizePeriodSelectorContainer: React.FC&amp;lt; IMemoizePeriodSelectorContainerProps&amp;gt; = ({ children }) =&amp;gt; { const periodContext = useContext(PeriodContext); return useMemo(() =&amp;gt; { return &amp;lt;&amp;gt;{children}&amp;lt;/&amp;gt;; }, [ periodContext?.state.date[0], periodContext?.state.date[1], periodContext?.state.selectTime[0], periodContext?.state.selectTime[1], ]);};export default MemoizePeriodSelectorContainer;원시값까지 가야하므로… 의존배열에 값이 좀 많다.이렇게 useMemo를 활용해서 컴포넌트를 메모이징 하여 해당 스테이트가 변경될때만 리렌더 시키는 방식으로 활용할 수도 있다.이것을 아래와같이 해당 컴포넌트에 적용시켜주면 된다.이렇게하면 return부분에 들어가는 캘린더와 같은부분은 리렌더가 되지 않아 렌더링 최적화를 어느정도 적용할 수 있다.다만 주의해야하는 점은 memoize된 방식의 사용을 위해서 useMemo를 적용할 때,위에서 만든것과 유사한 MemoizeContainer를 사용하는 경우 useContext를 통해 실제로 불러와 값을 넣어주는 부분 이하의 뎁스에서 이를 감싸줘야한다는 것이다import Calendar from &quot;components/calendar&quot;;import MemoizePeriodSelectorContainer from &quot;components/common/MemoizePeriodSelectorContainer&quot;;import { PeriodContext } from &quot;hooks/usePeriodSelector&quot;;import React, { useContext } from &quot;react&quot;;import { WrapperDate } from &quot;./styles&quot;;interface IPeriodSelectorProps { withTimes: boolean; labelText?: string;}const PeriodSelector: React.FC&amp;lt;IPeriodSelectorProps&amp;gt; = ({ withTimes, labelText,}): JSX.Element =&amp;gt; { const periodContext = useContext(PeriodContext); if (!periodContext?.state || !periodContext?.actions) throw new Error(&quot;Period Context를 주입해주세요&quot;); const { state: { date, selectTime }, actions: { handleStartDate, handleEndDate, handleTime }, } = periodContext; return ( //periodContext를 사용하는 해당 컴포넌트의 리턴부분 또는 그 아래의 Calendar컴포넌트 &amp;lt;MemoizePeriodSelectorContainer&amp;gt; &amp;lt;WrapperDate&amp;gt; &amp;lt;span&amp;gt;{labelText || &#39;기간 선택&#39;}&amp;lt;/span&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;Calendar date={date[0] || new Date()} handleDate={handleStartDate || (() =&amp;gt; null)} /&amp;gt; {withTimes &amp;amp;&amp;amp; handleTime &amp;amp;&amp;amp; selectTime &amp;amp;&amp;amp; ( &amp;lt;input type=&quot;time&quot; value={selectTime &amp;amp;&amp;amp; selectTime[0]} name=&quot;startTime&quot; onChange={handleTime} /&amp;gt; )} &amp;lt;/div&amp;gt; ... &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/WrapperDate&amp;gt; &amp;lt;/MemoizePeriodSelectorContainer&amp;gt; );};export default React.memo(PeriodSelector);이렇게 해서 마침내 hooks를 통해 분리했던 로직을 PropsDrilling없이, 그리고 스코프를 정해서 사용하는것이 가능해졌다.왜 이렇게 까지해서 ContextAPI를 쓰는걸까?Redux-Toolkit, Recoil, Atomic등 전역상태관리를 도와주는 아주 좋은 라이브러리들이 많다.이 라이브러리들은 객체 세부사항에 필요한 값만 가져온다면 해당 값이 변할때만 리렌더링을 최적화 시켜서 해주기도하고 포트폴리오에 스킬셋을 하나라도 더 적을 수 있으니 아주 좋은선택이다.그런데 내가 ContextAPI를 굳이 사용한 이유는 다른의미로 있다.크게 웹을 본다면 대부분은 대개 비슷한 구조를 아래와 같이 가져갈 것이다.- src - Page - Home - About - components Component.tsx ... - style styleA.tsx styleB.tsx ... - hooks useSomeHookA.ts ... - constants constantA.ts ... - Post - components common CommonA.tsx ...개인적으로는 페이지별로 사용하는 스타일, 상수, 유틸, hooks등을 페이지 아래에 폴더로 구성하여 필요한 곳에 가져다 쓰고중복이 되어 공용으로 사용이 되는 경우 src 바로 하단에 있는 폴더에 넣어 적절한 네이밍을 통해 공통으로 사용하는 방식을 취하고 있다.이 때, 위 예제와 같은 usePeriodSelectors 는 공용 hook이 될 것인데, 이를 사용하는 페이지 는 해당 컴포넌트(PeriodSelector.tsx)를 사용하는 페이지 일 것이다.그렇다면 hook + component의 조합으로 중복된 코드를 작성하지 않고 필요한곳에 import하여 로직과 뷰를 계속 재활용하며 사용할 수 있으므로 생산성이 상당히 높아진다.그런데 여기서 usePeriodSelectors라는 관련 state를 PropsDrilling을 피하고자 하는 이유로만 전역 store에 저장하고 있다고 가정하면 해당 컴포넌트를 사용하지 않는 페이지에서도 이 state에 대한 접근이 가능하게 된다.이는 해당 Hooks가 가진 서비스로직의 범주를 벗어나는 곳에서 사용(접근)이 되는 것이기 때문에 공동작업인 경우 자칫 의도하지 않는 역할이 시행될 수도 있다고 판단했다.(물론 그럴일은 절대 없겠지만 각 파일의 롤을 명확히 하고 싶은마음이 제일 컸다.)추가로 리액트가 함수지향적으로 개발이 되는것이 현재이나, 객체지향의 SOLID의 일부처럼 단일 책임(SRP)을 가지는 것이 중요하다고 판단하고 있는 개인적의견이 있다.때문에 해당 뷰에 해당하는 로직만 가지는것이 중요하다고 생각하고 있어 전역 저장소(Global Store)에 이를 저장하는것은 접근성의 문제로 의미가 맞지 않다고 판단되었다.그래서 해당 컴포넌트를 쓰는곳은 해당 컨텍스트 프로바이더를 통해 state를 주입받고 해당 컴포넌트는 항상 이 컨텍스트의 값만 쓰도록 설계를 한다면,적어도 반복되어 사용되는 컴포넌트는 해당 state만을 관리하므로 의미가 맞다고 생각한다.장점과 단점- 장점 Props Drilling을 피하며 깔끔한 코드상태를 유지할 수 있다. Nest.js의 컨셉과 유사한 느낌(OOP)으로 필요한 로직이 있다면 Service를 주입하는 것과 같은 느낌의 개발이 가능하다.- 단점 렌더링 최적화 하는 것에 손이 더욱 더 간다. (제발 memo의 콜백함수로 Context도 인지가 되는 날이 왔으면 좋겠다.) 자칫남용하면 return구문에서 여러개의 Provider를 동시에 만나게되므로 심미적으로 좋지 않다.참고 Github - facebook/react #15156 Preventing rerenders with React.memo and useContext hook Kent C. Dodds - How to use React Context effectively useMemo inside Context API - React - The Mindless" }, { "title": "리액트에서 비즈니스 로직을 나눠보자[2 - Hooks 를 테스트 해보자]", "url": "/posts/refactoring-2/", "categories": "FE, React", "tags": "Architecture", "date": "2022-01-18 12:33:00 +0900", "snippet": "테스트 코드 작성해보기이제 비즈니스로직을 모두 나누었으니 해당 비즈니스 로직에 대해서만 테스트를 진행해보자여러 테크기업들의 블로그를 뒤적이다. 리디의 블로그글을 가장 많이 참고하였다.그리하여 redux-mockstore와 testing-library/react-hooks 를 이용하여 테스트를 진행했다.우선 간단한 설명은 아래와 같다. mock-store를 통해 실제 액션을 리듀서까지 전달하여 업데이트하는 것이 아닌 어떤 액션이 dispatching되는지 확인한다. hooks mocking render 하여 필요한 메서드들을 빼와서 act 시킨 다음의 호출되는 액션을 mocking store를 통해 확인한다. localState의 경우 jest mock fn을 통해 처리한다.Business Logic1편에서 보았던 비즈니스 로직은 아래와 같고 onApply 테스트해보자.const usePersonnelManagementComponents = () =&amp;gt; { const history = useHistory(); const dispatch = useDispatch(); const { authPhase, mainPopup, companyInfoData } = useRootState( (state) =&amp;gt; state.global ); const storageToken = localStorage.getItem(&#39;access_token&#39;); const { address: addressPopup, certificate: certificatePopup, personnelManagement, } = MAIN_POPUP; const { basicInfoTitle, check, origin, path } = personnelManagement; const onApply = (phase:phaseType, token:string) =&amp;gt; { if (phase === &#39;logout&#39; &amp;amp;&amp;amp; !token) { return dispatch(setIsLoginModalVisible(true)); } //When Logged In dispatch( checkBasicCompanyInfoAction({ check: check as (keyof ICompanyInfo)[], domain: origin, path, }), ); }; useEffect(() =&amp;gt; { if (localStorage.getItem(&#39;isPaused&#39;) === &#39;true&#39;) { localStorage.removeItem(&#39;isPaused&#39;); actions.onApply(); } }, []); return { state: { mainPopup, storageToken, ... }, actions: { onApply, ... }, };};export default usePersonnelManagementComponents;onApply의 구조는 간단한데 들어온 인자들에 대해서 특정조건에 따라 dispatching하는 액션이 달라지게 된다.그래서 두가지 케이스에서 테스트를 진행할 수 있게 되고 아래와 같이 진행했다.describe(&quot;usePersonnel&quot;, () =&amp;gt; { const setup = () =&amp;gt; { const store = createMockStore(); const { result, waitForNextUpdate } = renderHook(() =&amp;gt; usePersonnel(), { wrapper: ({ children }: { children: React.ReactNode }) =&amp;gt; ( &amp;lt;Provider store={store}&amp;gt;{children}&amp;lt;/Provider&amp;gt; ), }); return { store, result, waitForNextUpdate }; }; describe(&quot;onApply&quot;, () =&amp;gt; { it(&quot;토큰이 존재하고 phase가 logout인 경우 로그아웃 요청을 위한 action 호출&quot;, () =&amp;gt; { const { result, store } = setup(); const MOCK_PHASE = phaseType.logout; //enum const MOCK_TOKEN = &quot;MOCK_TOKEN&quot;; act(() =&amp;gt; { result.current.actions.onApply(MOCK_PHASE, MOCK_TOKEN); }); expect(store.getActions()).toEqual([setIsLoginModalVisible(true)]); }); });}); 위와 같은 방식으로 해당 hooks를 라이브러리에 존재하는 renderHook 메서드를 활용해서 불러주고 mockStore를 만들어 action을 가져올 수 있게 하였다. 그리고 렌더 후 필요한 actions와 state를 가져오기 위해 setup() 메서드를 호출해와서 필요한 액션을 불러오고 그 결과에 알맞는 결과값이 도출되는지 확인한다.위 예시로는 굉장히 간단해보이지만 만약 조건이 많고 복잡한 로직이 컴포넌트 내부에 내재되어있는 상황이라면 충분히 유용하게 이러한 hooks를 통한 테스트를 활용할 수 있을 것 같다.하지만 해당테스트 샘플을 자세히 보면 문제가 있다고 생각이 들 것이다.장단점을 나열하며 생각해보자.장점과 단점 장점 간단한 비즈니스로직이라도 휴먼에러는 언제나 존재하니 이런식으로 재빠르게 테스트를 진행하고 개발을 한다면 안정성이 증가 될 것 같다. 분리를 하면 할 수록 내 코드가 얼마나 난장판인지 알 수 있게 된다. 사이드이펙트를 의도적으로 줄이고 순수함수를 지향하게 된다. hooks를 통한 테스트에서는 내부 state를 변경하는 바보같은 짓(계속 시도했었음 ㅎㅅㅎ..)을 하기 위한 것이 아닌 해당 메서드가 요청하는 인자를 넘겼을 때 원하는 값이 나오도록 하는것을 보장하는것이 주된 목적이다. 그래서 함수의 side effect를 발생시키기 위해 인자에 넣지 않고(리팩토링의 시간) 곧바로 함수에서 state를 참조해서 변경해주는 것을 지양하게 된다. 위의 onApply도 check, origin, path를 인자로 받는 것이 제대로된 테스트가 되겠다. 단점 파일의 수와 테스트코드의 수가 늘어나게 된다. 불필요하다고 판단되는 로직마저 아무생각없이 테스트하고 있는 자신을 발견한다. 리팩토링 시 파일 열기가 귀찮다 사실 단점은 거의 없는 것 같다. 끝!참고 How to Create a Three-Layer Application with React Hooks RIDI-리덕스 잘 쓰고 계시나요? testing-library / react-hooks-testing-library npm-redux-mock-store" }, { "title": "리액트에서 비즈니스 로직을 나눠보자[1 - 비즈니스로직 분리]", "url": "/posts/refactoring-1/", "categories": "FE, React", "tags": "Architecture", "date": "2021-12-15 12:33:00 +0900", "snippet": "왜 하게 되었냐면회사에서 개발자 다수가 이탈하게 되면서 빠른 유지보수와 코드의 정확성을 높이는 일이 나에게도, 회사에게도 중요해졌다.현재 리액트 프로젝트에서 Toolkit과 Saga를 통해서 나름 나눈다고 나눴지만 이 과정에서 불필요한 코드들도 많아졌고,실제로 state나 hooks와 연결된 부분은 컴포넌트에 그대로 남아있게 되었다. 그래서 리팩토링이 필요한 상황이었다.마침 앵귤러로 진행된 다른 프로젝트를 조금씩 리액트로 포팅하는 와중이라 앵귤러의 구현 개념을 맛보고 즐기고 있었는데,Nest JS에서 했던 방식과 유사하게(역시 같은팀이 맞다. 공식문서 말대로 똑같음) Service와 Controller가 나눠진 상태였고리액트에서도 이와 같은 방식은 아니더라도 로직과 뷰의 분리는 필요하다고 판단되었다.크게 진행한 이유를 두가지 정도 들 수 있다. 테스트 코드 짜는데 너무 힘들다 예를 들어 Jest를 통해 해당 앱의 뷰를 테스트 시키는 것만해도 모든 함수들에게 적절하게 state가 들어가게 선언된 hook등을 모두 넘겨주어야했다. 비즈니스로직과 뷰를 나눌 수 있게 된다면 로직을 위한 테스트와 뷰를 위한 테스트를 별도로 짤 수 있게 되므로 뷰만 변경 된 경우 로직쪽 테스트 파일은 그대로 남겨둬도 되는 장점이생긴다. 물론 하나의 파일로 전체를 테스트해도 되지만 여간 긴것도 문제고 보기가 힘들다 .. (눈이 아프다.) 유지보수 할 때 마다 짜증이 난다. TSX 파일을 열때마다 무수한 비즈니스 로직이 연결되어있는 그 스크롤을 내려야 비로소 내가 간단하게 수정할 태그들이 보이는 것이 불편하다. 가령 state하나 간단하게 선언해서 모달만 초기 렌더시에 띄워주면 되는 간단한 상황에서도 해당 파일 전체가 수정되는 것이 별로다. 그냥 코드가 못생겨보인다. 그리고 퇴사자들의 여러가지 기존 코드를 CTO님께서 뜯어보시고 프론트쪽에 많은 의문을 품으셔서 이왕 사람도 적어진 김에 많은 질문을 드렸고 수확이 컸다. 앱(웹 어플리케이션)에서의 작은 규모인 경우 레이어를 나누는 것이 더 복잡해 보이는 경우가 있어서 개발초기에는 레이어의 나눔이 무의미할 수도 있다. 규모가 큰 경우 유지보수 및 테스트 코드 작성의 효율(진짜 이건 작성해보면 뼈져리게 느껴진다.)을 위해서는 나누는 것이 굉장히 효율적이다. 새로운 사람이 해당 코드를 봤을 때 구조를 통해서 이해가 용이해질 수도 있다. 지금 리팩토링을 진행하면서 한번에 어떤구조를 정해서 적용하는 것이 아니라 하나씩 필요한 부분을 분리해 나아가면서 부족한 개념을 찾아서 공부하다보면 패턴이 자연스럽게 공부가 된다 이제 끝까지 다 쪼개면 Atomic Pattern이 되는 것.. 이제껏 요청한 UI, 기능들을 일정 무리 없이 뽑아내었던 상태라 크게 코드쪽을 신경쓰시지 않으셨었는데(인원수도 적고 해야할 일의 양자체도 많았었다.)이제는 좀 리뷰를 해주시고 도움을 주시겠다고 하셨다 ㅎㅎ..(많이 심각한가 보다.)그래서 리팩토링하기에 정말 좋은 재료로서의 코드라고 이야기해주셔 그 여정을 나름 포스팅으로 담아보려고 작성을 하게 되었다.Business Logic일단 비즈니스 로직의 정의를 컴포넌트 내부에서 이루어지는 Actions로 정의했다.가령 아래코드의 onApply 같은 코드가 될 수 있다.글로벌 스테이트를 사용하고 다양한 로직을 통해 state를 변경할 액션을 dispatch한다거나, 비동기 처리로 데이터를 불러오는등의 역할을 하는 것들이다.export default function FirstSection() { const history = useHistory(); const dispatch = useDispatch(); const storageToken = localStorage.getItem(&#39;access_token&#39;); const { authPhase, mainPopup, companyInfoData } = useRootState( (state) =&amp;gt; state.global, ); const { basicInfoTitle, check, origin, path } = personnelManagement; const { corpName, charger, chargerTel, address, addressDetail } = companyInfoData; const onApply = (phase:phaseType, token:string) =&amp;gt; { if (phase === &#39;logout&#39; &amp;amp;&amp;amp; !token) { return dispatch(setIsLoginModalVisible(true)); } dispatch( checkBasicCompanyInfoAction({ check: check as (keyof ICompanyInfo)[], domain: origin, path, }), ); }; useEffect(() =&amp;gt; { if (localStorage.getItem(&#39;isPaused&#39;) === &#39;true&#39;) { localStorage.removeItem(&#39;isPaused&#39;); onApply(authPhase, storageToken); } }, []); return ( &amp;lt;&amp;gt; &amp;lt;FirstSectionWrapper&amp;gt; &amp;lt;HeaderTextWrapper&amp;gt; &amp;lt;AText color=&quot;black100&quot; size={45} bold&amp;gt; 비즈니스로직으로{authPhase} &amp;lt;/AText&amp;gt; &amp;lt;AText color=&quot;black100&quot; size={45} bold&amp;gt; 분리를 제발하자 &amp;lt;/AText&amp;gt; &amp;lt;/HeaderTextWrapper&amp;gt; &amp;lt;FirstSectionButtonWrapper&amp;gt; &amp;lt;ABasicButton /&amp;gt; &amp;lt;ABasicButton onClick={()=&amp;gt;onApply(authPhase, storageToken)} /&amp;gt; &amp;lt;/FirstSectionButtonWrapper&amp;gt; &amp;lt;/&amp;gt; );}그래서 위와 같은 코드를 아래와 같이 파일을 분리하여 개선하는 방향을 생각할 수 있다.컴포넌트만 놓고 보았을때, 일단 로직을 분리할 수 있게 되어 필요한 state나 actions만 custom hooks에서 가져와 선언 또는 호출을 하면 된다.다만 이 상태에서 아쉬운 점은 뷰가 완전히 분리되었다고 볼 수 없는 상태이다.예를 들어 FirstSection이라는 위에 하나의 파일로 작성된 파일을(뷰랑 컴포넌트 짬뽕) 테스트에 들어가게 된다면,dispatch와 나머지 hook를 가지고와서 선언을 해준 뒤 테스트를 해줘야하는데명확히 뷰의 역할만 하는 것이 아니라고 판단이 되기 때문이다.그래서 추후에 뷰는 Props로 필요한 로직+state만 넘겨 처리하는 방식으로 진행하고 테스트에서는 이 Props를 유연하게만약 onApply가 console.log(‘Hello’)만 실행하는 함수라도 뷰단에서의 올바름을 테스트한다는 가정만 하면 어떤 함수가 들어가도 해당 뷰를 클릭하면props로 전달받은 함수만 작동하는것을 테스트하면 되기때문에 그렇게 진행할 생각이다.(아직까진..)그래서 아래는 cutomhooks을 통해 파일마다 R&amp;amp;R을 정할 수 있게 일차원적으로 분리한 상태의 뷰 파일이다.export default function FirstSection() { const { actions, state } = usePersonnelManagementComponents(); const {onApply} = actions; const {authPhase, storageToken} = state; return ( &amp;lt;&amp;gt; &amp;lt;FirstSectionWrapper&amp;gt; &amp;lt;HeaderTextWrapper&amp;gt; &amp;lt;AText color=&quot;black100&quot; size={45} bold&amp;gt; 비즈니스로직으로{authPhase} &amp;lt;/AText&amp;gt; &amp;lt;AText color=&quot;black100&quot; size={45} bold&amp;gt; 분리를 제발하자 &amp;lt;/AText&amp;gt; &amp;lt;/HeaderTextWrapper&amp;gt; &amp;lt;FirstSectionButtonWrapper&amp;gt; &amp;lt;ABasicButton /&amp;gt; &amp;lt;ABasicButton onClick={()=&amp;gt;onApply(authPhase, storageToken)} /&amp;gt; &amp;lt;/FirstSectionButtonWrapper&amp;gt; &amp;lt;/&amp;gt; );}아래는 분리한 서비스 로직이다.사실 그냥 복붙한 것과 같은 것이다(아직은 ..)const usePersonnelManagementComponents = () =&amp;gt; { const history = useHistory(); const dispatch = useDispatch(); const { authPhase, mainPopup, companyInfoData } = useRootState( (state) =&amp;gt; state.global ); const storageToken = localStorage.getItem(&#39;access_token&#39;); const { address: addressPopup, certificate: certificatePopup, personnelManagement, } = MAIN_POPUP; const { basicInfoTitle, check, origin, path } = personnelManagement; const onApply = (phase:phaseType, token:string) =&amp;gt; { if (phase === &#39;logout&#39; &amp;amp;&amp;amp; !token) { return dispatch(setIsLoginModalVisible(true)); } //When Logged In dispatch( checkBasicCompanyInfoAction({ check: check as (keyof ICompanyInfo)[], domain: origin, path, }), ); }; useEffect(() =&amp;gt; { if (localStorage.getItem(&#39;isPaused&#39;) === &#39;true&#39;) { localStorage.removeItem(&#39;isPaused&#39;); actions.onApply(); } }, []); return { state: { mainPopup, storageToken, ... }, actions: { onApply, ... }, };};export default usePersonnelManagementComponents;이렇게 컴포넌트 내부에 선언되었던 함수나 state를 다른 파일로 넘겨온 뒤 state, actions 로 별도 제공을 해주고컴포넌트 내부에서는 필요한 로직과 state만 가져오게 만드는 것이다.문제점 만약 하나의 파일이 굉장히 작은 비즈니스로직을 가지고 있다면 불필요하게 분리할 필요가 없다는 것이라는 생각이든다. 뭔가 팀에서의 컨벤션이 제대로 이루어진 상태에서 로직분리를 적용하는 것이 많는 것 같다. 가령 하나의 버튼에 로직이 들어간다면 (이러면 안되긴하지만) 굳이 분리를 시킬 필요도 없지 않을까 싶다. 로컬스테이트와 글로벌 스테이트가 하나의 함수에 합쳐져 동시에 동작을 해야할때 사실 로컬스테이트를 굳이 hooks에 집어넣어야 싶은 생각도 든다. 결국 비즈니스로직의 분리는 각 컴포넌트 or 페이지 마다 중복되는 로직의 최소화를 위해서인데 로컬 스테이트는 결국 그 로컬에서만 쓰일 용도니 말이다. 그래서 생각한 방식은 일단은 리팩토링이니 hooks에 모두 집어넣고 중복되는 로직을 다른 hooks로 분리하여 글로벌하게 쓰일 수 있도록 변경한 뒤 해당 페이지 또는 컴포넌트에 쓰여야하는 Hooks를 별도로 만들어 테스트하는 방식이 괜찮은 것 같다. 2편은 testing-library/react-hooks를 통해서 테스트를 진행한 것을 포스팅 해보겠다! 끝!참고 How to Create a Three-Layer Application with React Hooks" }, { "title": "LeetCode 문제풀이(704.Binary Search)", "url": "/posts/LeetCode.BinarySearch/", "categories": "LeetCode, BinarySearch", "tags": "Algorithm", "date": "2021-12-03 12:33:00 +0900", "snippet": "시작하게 된 이유리트코드 14일 알고리즘 부시기 코스라고 적혀있는 것을 시작한 이유는 최근 프로그래머스를 통해 자료구조 강의를 보고 있기 때문이다.프로그래머스에서 1단계 문제를 모두 풀고 난 뒤 2단계를 하려던 와중 기본지식(자료구조, 알고리즘 개념)이 부족하여 강의를 이것저것 찾아 듣고있는 상태인데 그래도 유명하다는 리트코드 Easy레벨 문제도 풀어봐야 되지 않겠나.. 라는 생각으로 접했는데생각보다 꽤 어렵다 ㅎㅅㅎ..1. 704.Binary SearchGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.Example 1:Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1Constraints:1 &amp;lt;= nums.length &amp;lt;= 104-104 &amp;lt; nums[i], target &amp;lt; 104All the integers in nums are unique.nums is sorted in ascending order.2. 풀이const search = (nums, target) =&amp;gt; { let low = 0; let high = nums.length - 1; let mid = 0; //종결 조건은 찾거나 미들이 0 일때임 //계속 돌면서 리스트의 중간 값이 타겟보다 큰 경우 // 리스트의 중간값이 타겟보다 작은 경우 while (low &amp;lt;= high) { mid = Math.floor((low + high) / 2); if (nums[mid] === target) { return mid; } else if (nums[mid] &amp;gt; target) { high = mid - 1; } else { low = mid + 1; } } return -1;};search([-1, 0, 3, 5, 1, 9], 9);3. 결론간단하게 이중 for문을 돌려 o^n으로도 풀 수 있다mid에 관한 방법은 처음에 Math.ceil로 접근했으나 Math.floor가 미세하게 더 빨랐다.아무래도 테스트케이스의 차이인가 싶기도하다끝!참고 [LeetCode - 704.Binary Search]](https://leetcode.com/problems/binary-search/)" }, { "title": "SQL공부를 조금이라도 하자[프로그래머스 문제 풀기]", "url": "/posts/sql-test/", "categories": "BE, SQL", "tags": "SQL", "date": "2021-10-13 12:33:00 +0900", "snippet": "SQL정리한 이유매번 TypeORM의 엄청난 도움을 받으며 포트폴리오를 위한 서버를 구현하다가팔로우 관계와 유사한 기능이 있는 경우M:N으로 조인된 컬럼의 데이터를 지워줘야하는 필요성이 생겼다.그래서 queryBuilder를 통해서 지워주는 방법이 있다는 것을 알게되고 간단한 방법으로 구현하게는 되었으나,언젠가 SQL의 깊지는 않아도 간단한 문법은 구현할 수 있어야한다는 생각으로프로그래머스 문제-SQL 고득점 Kit를 풀어보았다.아래는 간략하게 풀며 정리한 내용이며 추가적으로 신기한 구현방법이 있으면 수정하겠다.1. SELECT모든 레코드 조회하기동물 보호소에 들어온 모든 동물의 정보를 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요.SELECT * FROM ANIMAL_INS ORDER BY ANIMAL_ID ASC ASC ,DEC 는 각 각 오름차순, 내림차순을 뜻한다.역순 정렬하기동물 보호소에 들어온 모든 동물의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 ANIMAL_ID 역순으로 보여주세요.SELECT NAME, DATETIMEFROM ANIMAL_INSORDER BY ANIMAL_ID DESC;아픈 동물 찾기SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITIONLIKE &#39;Sick&#39;ORDER BY ANIMAL_ID ASC;문자열을 찾을때는 LIKE를 사용하자추가적으로 %, _가 있는데 앞뒤로 무시 or 무엇이든 을 뜻하게 된다아래 간단한 두가지 예제를 보자SELECT NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITIONLIKE &#39;_Sick&#39;ORDER BY ANIMAL_ID ASC;앞에 어떤 sick가 나오는 것을 찾게된다 ex)asickSELECT NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITIONLIKE &#39;&amp;amp;Sick&#39;ORDER BY ANIMAL_ID ASC;앞에 어떤것이 나오든 sick가 들어있는 것을 찾게된다 ex)ㅁㄴㅇㄹㅁㅇㄴㄹㄴㅁㅇㄹㅁsick조합해서도 사용 가능하다어린 동물 찾기동물 보호소에 들어온 동물 중 젊은 동물1의 아이디와 이름을 조회하는 SQL 문을 작성해주세요. 이때 결과는 아이디 순으로 조회해주세요.SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE NOT INTAKE_CONDITIONLIKE &#39;Aged&#39;ORDER BY ANIMAL_ID ASC;동물의 아이디와 이름동물 보호소에 들어온 모든 동물의 아이디와 이름을 ANIMAL_ID순으로 조회하는 SQL문을 작성해주세요.SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSORDER BY ANIMAL_ID ASC;여러 기준으로 정렬하기동물 보호소에 들어온 모든 동물의 아이디와 이름, 보호 시작일을 이름 순으로 조회하는 SQL문을 작성해주세요. 단, 이름이 같은 동물 중에서는 보호를 나중에 시작한 동물을 먼저 보여줘야 합니다.SELECT ANIMAL_ID, NAME, DATETIMEFROM ANIMAL_INSORDER BY NAME, DATETIME DESC;상위 n개 레코드동물 보호소에 가장 먼저 들어온 동물의 이름을 조회하는 SQL 문을 작성해주세요.SELECT NAME FROM ANIMAL_INSWHERE DATETIME = (SELECT MIN(DATETIME)FROM ANIMAL_INS);WHERE문을 써서 조건을 줄 수 있으며 GROUP BY로 묶여진 경우 HAVING문을 써주면 된다.2. SUM, MAX, MIN최댓값 구하기가장 최근에 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.SELECT MAX(DATETIME) FROM ANIMAL_INS;최솟값 구하기동물 보호소에 가장 먼저 들어온 동물은 언제 들어왔는지 조회하는 SQL 문을 작성해주세요.SELECT MIN(DATETIME) FROM ANIMAL_INS;동물 수 구하기동물 보호소에 동물이 몇 마리 들어왔는지 조회하는 SQL 문을 작성해주세요.SELECT COUNT(*) FROM ANIMAL_INS;중복 제거하기동물 보호소에 들어온 동물의 이름은 몇 개인지 조회하는 SQL 문을 작성해주세요.이때 이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 칩니다.SELECT COUNT(DISTINCT NAME)FROM ANIMAL_INSWHERE NAME IS NOT NULL;3. GROUP BY고양이와 개는 몇 마리 있을까동물 보호소에 들어온 동물 중 고양이와 개가 각각 몇 마리인지 조회하는 SQL문을 작성해주세요. 이때 고양이를 개보다 먼저 조회해주세요.SELECT ANIMAL_TYPE, COUNT(ANIMAL_TYPE) FROM ANIMAL_INS GROUP BY ANIMAL_TYPE ORDER BY ANIMAL_TYPE-&amp;gt; ORDER BY ANIMAL_TYPE 는 고양이를 먼저 조회하기 위해 사용동명 동물 수 찾기동물 보호소에 들어온 동물 이름 중 두 번 이상 쓰인 이름과 해당 이름이 쓰인 횟수를 조회하는 SQL문을 작성해주세요. 이때 결과는 이름이 없는 동물은 집계에서 제외하며, 결과는 이름 순으로 조회해주세요.1.첫번째 시도SELECT NAME, COUNT(NAME) FROM ANIMAL_INS WHERE COUNT(NAME)&amp;gt;=1 GROUP BY NAME ORDER BY NAME그룹을 묶은 다음 조건을 쓰기 위해서는 HAVING을 써야한다고 한다..2.두번째 시도SELECT NAME, COUNT(NAME) FROM ANIMAL_INS GROUP BY NAME HAVING COUNT(NAME)&amp;gt;1 ORDER BY NAME입양 시각 구하기(1)보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다.SELECT HOUR(DATETIME), COUNT(HOUR(DATETIME)) FROM ANIMAL_OUTS GROUP BY HOUR(DATETIME) HAVING HOUR(DATETIME) &amp;gt;= 09 AND HOUR(DATETIME) &amp;lt; 20 ORDER BY HOUR아래와 같이 변수선언 쌉가능 …SELECT HOUR(DATETIME) HOUR, COUNT(DATETIME) FROM ANIMAL_OUTS GROUP BY HOUR(DATETIME) HAVING HOUR &amp;gt;= 9 AND HOUR &amp;lt; 20 ORDER BY HOUR입양 시각 구하기(2)이문제는 처음에 입양 시각 구하기(1)의 문제와 유사하게 작성하였는데 0~23이라는 범위에서 아는 지식을 넘어갔으므로 .. 검색을 열심히했다 :)SET @hour := -1;SELECT (@hour := @hour + 1) as HOUR,(SELECT COUNT(*) FROM ANIMAL_OUTS WHERE HOUR(DATETIME) = @hour) as COUNTFROM ANIMAL_OUTSWHERE @hour &amp;lt; 23;4. IS NULL이름이 없는 동물의 아이디동물 보호소에 들어온 동물 중, 이름이 없는 채로 들어온 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.SELECT ANIMAL_ID FRoM ANIMAL_INS WHERE NAME IS NULL ORDER BY ANIMAL_ID ASC이름이 있는 동물의 아이디동물 보호소에 들어온 동물 중, 이름이 있는 동물의 ID를 조회하는 SQL 문을 작성해주세요. 단, ID는 오름차순 정렬되어야 합니다.SELECT ANIMAL_ID FROM ANIMAL_INS WHERE NAME IS NOT NULL ORDER BY ANIMAL_ID ASCNULL 처리하기1차시도 -&amp;gt; 뭔가 이렇게 하면 될 것 같다는 막연한 생각으로 도전 ..SELECT ANIMAL_TYPE, NAME, SEX_UPON_INTAKEFROM ANIMAL_INSWHERE NAME IS NULL AS &#39;NO Name&#39;ORDER BY ANIMAL_ID ASC당연히 안됬다찾아보니 null처리 해주는 메서드? 문법? 이 따로 있다 :) …..IFNULL(해당 컬럼, null이름을 뭘로바꿀지) 로 사용하면 된다SELECT ANIMAL_TYPE, IFNULL(NAME,&#39;No name&#39;), SEX_UPON_INTAKEFROM ANIMAL_INSORDER BY ANIMAL_ID ASC;5. JOIN없어진 기록 찾기천재지변으로 인해 일부 데이터가 유실되었습니다. 입양을 간 기록은 있는데, 보호소에 들어온 기록이 없는 동물의 ID와 이름을 ID 순으로 조회하는 SQL문을 작성해주세요.left outer 조인은 명명한 테이블 기준으로 오른쪽에 붙이는 테이블이 빈값이면 null을 반환해주므로 아래와 같이 작성아래에서는 ANIMAL_INS가 LEFT OUTER JOIN에 명명되었으므로 INS 기준으로 OUTS가 붙게된다.보통 LEFT JOIN이라고 칭하는게 LEFT OUTER JOIN 이다.조인할 테이블이면 보통 외래키가 있으므로 ON을 통해 해당 외래키를 연결하면 됨SELECT OUT_A.ANIMAL_ID, OUT_A.NAMEFROM ANIMAL_OUTS AS OUT_ALEFT OUTER JOIN ANIMAL_INS AS IN_AON OUT_A.ANIMAL_ID = IN_A.ANIMAL_IDWHERE IN_A.ANIMAL_ID IS NULLORDER BY OUT_A.ANIMAL_ID ASC있었는데요 없었습니다관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다.1차시도아래와 같이하면 문제가 없을 줄 알았음 -&amp;gt; 안됨 -&amp;gt; 중복케이스도 다 나오게 된다SELECT IN_A.ANIMAL_ID, IN_A.NAMEFROM ANIMAL_INS AS IN_A, ANIMAL_OUTS AS OUT_AWHERE IN_A.DATETIME &amp;gt; OUT_A.DATETIME2차시도SELECT OUT_A.ANIMAL_ID, OUT_A.NAMEFROM ANIMAL_OUTS AS OUT_ALEFT OUTER JOIN ANIMAL_INS AS IN_AON OUT_A.ANIMAL_ID = IN_A.ANIMAL_IDWHERE IN_A.DATETIME &amp;gt; OUT_A.DATETIMEORDER BY IN_A.DATETIME ASC오랜 기간 보호한 동물(1)아직 입양을 못 간 동물 중, 가장 오래 보호소에 있었던 동물 3마리의 이름과 보호 시작일을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일 순으로 조회해야 합니다.1차시도정렬 후 limit만 걸면 될 줄 알았다.SELECT IN_A.NAME, IN_A.DATETIMEFROM ANIMAL_INS AS IN_ALEFT OUTER JOIN ANIMAL_OUTS AS OUT_AON IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDORDER BY IN_A.DATETIME ASCLIMIT 32차시도ANIMAL_INS에 존재하지 않는 정보가 있다면 OUT_A.ANIMAL_ID 는 null값으로 되며 조인 되기때문에이 부분을 처리해줘야한다SELECT IN_A.NAME, IN_A.DATETIMEFROM ANIMAL_INS AS IN_ALEFT OUTER JOIN ANIMAL_OUTS AS OUT_AON IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDWHERE OUT_A.ANIMAL_ID IS NULLORDER BY IN_A.DATETIME ASCLIMIT 3보호소에서 중성화한 동물보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 보호소에 들어올 당시에는 중성화1되지 않았지만, 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요.1차시도뭐가 문제일까 한참 본 쿼리이다SELECT OUT_A.ANIMAL_ID, OUT_A.ANIMAL_TYPE, OUT_A.NAMEFROM ANIMAL_OUTS AS OUT_ALEFT OUTER JOIN ANIMAL_INS AS IN_AON IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDWHERE IN_A.SEX_UPON_INTAKE LIKE &quot;%Intact%&quot;AND OUT_A.SEX_UPON_OUTCOME IN(&#39;%Neutered%&#39;, &#39;%Spayed%&#39;);2차시도그냥 풀어서 적용하고 괄호치니까 잘됬다그러면 IN조건이 조금 문제인듯 하다..IN 안에서는 %, _ 이런게 안되나보다 ㅇㅁㅇ… (되게 해주지 편할텐데)SELECT OUT_A.ANIMAL_ID, OUT_A.ANIMAL_TYPE, OUT_A.NAMEFROM ANIMAL_OUTS AS OUT_ALEFT OUTER JOIN ANIMAL_INS AS IN_AON IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDWHERE IN_A.SEX_UPON_INTAKE LIKE &quot;%Intact%&quot;AND (OUT_A.SEX_UPON_OUTCOME LIKE &quot;%Neutered%&quot; OR OUT_A.SEX_UPON_OUTCOME LIKE &quot;%Spayed%&quot;);번외로 어떤분의 풀이중에서는 그냥 이름 다른것만 찾아서 리턴시키는분도 계셨다천재인가보다.백엔드 개발자 분에게 물어보니 정규식도 좋은 방법이라 하셨다역시 천재는 많다 :) …SELECT OUT_A.ANIMAL_ID, OUT_A.ANIMAL_TYPE, OUT_A.NAMEFROM ANIMAL_OUTS AS OUT_ALEFT OUTER JOIN ANIMAL_INS AS IN_AON IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDWHERE IN_A.SEX_UPON_INTAKE LIKE &quot;%Intact%&quot;AND OUT_A.SEX_UPON_OUTCOME REGEXP (&#39;neutered|spayed&#39;);6. String, Date루시와 엘라 찾기동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL 문을 작성해주세요.1차시도이렇게 해야하나 싶을정도로 무지한 상태이기 때문에 도전을 해보았지만 .. IN 문법이 있다는 것을 알게되었다.그리고 아래와 같이 시도하면 Lucy케이스 이외에는 적용되지 않는다.SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKEFROM ANIMAL_INSWHERE NAME LIKE &#39;Lucy&#39; OR &#39;Ella&#39; OR &#39;Pickle&#39; OR &#39;Rogan&#39; OR &#39;Sabrina&#39; OR &#39;Mitty&#39;;2차시도IN 문법 적용SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKE FROM ANIMAL_INS WHERE NAME IN(&#39;Lucy&#39;,&#39;Ella&#39;, &#39;Pickle&#39;, &#39;Rogan&#39;, &#39;Sabrina&#39;, &#39;Mitty&#39;);이름에 el이 들어가는 동물 찾기보호소에 돌아가신 할머니가 기르던 개를 찾는 사람이 찾아왔습니다. 이 사람이 말하길 할머니가 기르던 개는 이름에 ‘el’이 들어간다고 합니다. 동물 보호소에 들어온 동물 이름 중, 이름에 “EL”이 들어가는 개의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 이름 순으로 조회해주세요. 단, 이름의 대소문자는 구분하지 않습니다.개인프로젝트를 하면서 검색등을 위해 몇번씩 구현해본 것이라 쉽게 가능SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE NAME LIKE &#39;%el%&#39; AND ANIMAL_TYPE=&#39;Dog&#39;ORDER BY NAME ASC오랜 기간 보호한 동물(2)입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 기간이 긴 순으로 조회해야 합니다.이건 뭐 문제보고 한 5분만에 그냥 찾아봤다지식이 거의 없어서 혼자 삽질할빠에 빨리 답을알고 잘 적용하는게 더 시간아끼는길이라 판단이 되어 …(변명인가)여튼 외래키 사용까지는 알고 있었는데 LIMIT를 몰랐다 .. ㅎㅎ..ㅎ.ㅎ 중복케이스가 나와도 상위 2개만을 잡기때문에 해결에 문제는 없지만 더 정확한 것은 join 을 통해서 해결하면 좋다.SELECT IN_A.ANIMAL_ID, IN_A.NAMEFROM ANIMAL_INS AS IN_A, ANIMAL_OUTS AS OUT_AWHERE IN_A.ANIMAL_ID = OUT_A.ANIMAL_IDORDER BY OUT_A.DATETIME - IN_A.DATETIMEDESC LIMIT 2중성화 여부 파악하기보호소의 동물이 중성화되었는지 아닌지 파악하려 합니다. 중성화된 동물은 SEX_UPON_INTAKE 컬럼에 ‘Neutered’ 또는 ‘Spayed’라는 단어가 들어있습니다. 동물의 아이디와 이름, 중성화 여부를 아이디 순으로 조회하는 SQL문을 작성해주세요. 이때 중성화가 되어있다면 ‘O’, 아니라면 ‘X’라고 표시해주세요.1차시도분명 무슨 조건문 같은거 쓸 수 있을 것 같은데 그게 뭔지 몰라서 일단 …SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKEFROM ANIMAL_INSWHERE SEX_UPON_INTAKE LIKE &#39;%Neutered%&#39; OR SEX_UPON_INTAKE LIKE &#39;%Spayed%&#39;2차시도그래서 CASE WHEN THEN ELSE END 조합으로 사용하는 방법을 알게되었다.그리고 LIKE IN(‘a’,’b’) 와 같은 행위가 되지않는것도 알게되었다 ㅇㅅㅇ..SELECT ANIMAL_ID, NAME,CASE WHEN SEX_UPON_INTAKE LIKE &quot;%Neutered%&quot; OR SEX_UPON_INTAKE LIKE &quot;%Spayed%&quot; THEN &quot;O&quot; ELSE &quot;X&quot; END AS &quot;중성화&quot;FROM ANIMAL_INSDATETIME에서 DATE로 형 변환ANIMAL_INS 테이블에 등록된 모든 레코드에 대해, 각 동물의 아이디와 이름, 들어온 날짜1를 조회하는 SQL문을 작성해주세요. 이때 결과는 아이디 순으로 조회해야 합니다.1차시도얼추 이렇게 폼 잡아주면 될 것 같았는데 안됨SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#39;yyyy-mm-dd&#39;) AS &#39;날짜&#39; FROM ANIMAL_INS ORDER BY ANIMAL_ID ASC`2차시도정해진 형식이 있다..%Y는 4자리 년도 %y는 2자리 연도라고 한다.SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, &#39;%Y-%m-%d&#39;) AS &#39;날짜&#39; FROM ANIMAL_INS ORDER BY ANIMAL_ID ASC`참고 w3school-SQL Tutorial 프로그래머스 문제-SQL 고득점 Kit Smile virus - 개인 티스토리 블로그 w3school- leftjoin " }, { "title": "Next JS를 공부해보자[2편-Auth]", "url": "/posts/nextjs_user/", "categories": "FE, Next JS", "tags": "Next JS", "date": "2021-10-06 12:33:00 +0900", "snippet": "Next JS사용하는 이유1편을 통한 간단한 개념잡기 이후에 Next js, Apollo-client 조합으로 쿼리를 이용할 수 있는 훅(useQuery 등)을 활용하여 로그인 로그아웃을 구현해보자!1. 세팅일단 기본적으로 next-apollo 의 샘플 깃헙 코드를 통해 대부분의 세팅을 진행하였고 추가적으로 link를 설정해서 헤더만 잡아주었다.물론 이걸 지금 활용을 거의 못하고 있긴한데.. 수정사항이나 더 좋은 것이 생기면 포스팅을 수정해봐야겠다.일단 현재 진행중인 개인프로젝트에서 사용한 것이므로 간단한 앱의 구조부터 설명을 하면 좋을 것 같아 \\_app의 코드 먼저보고 시작하겠다const App = ({ Component, pageProps }) =&amp;gt; { const apolloClient = useApollo(pageProps); return ( &amp;lt;ApolloProvider client={apolloClient}&amp;gt; &amp;lt;Wrapper&amp;gt; &amp;lt;Layout&amp;gt; &amp;lt;Component {...pageProps} /&amp;gt; &amp;lt;/Layout&amp;gt; &amp;lt;/Wrapper&amp;gt; &amp;lt;/ApolloProvider&amp;gt; );};export default wrapper.withRedux(App);별도로 생성한 useApollo를 통해 생성한 클라이언트를 ApolloProvider로 넣어주고 Wrapper를 통해 전역 스타일을 넣어주었다LayOut을 통해 Header, Footer를 모든 컴포넌트 내에서 동일하게 보여주는 방식을 취한다리액트로 진행할때는 loggedInRouter, loggedOutRouter를 나눠서 진행했던 라우팅방시에서 조금 차이를 둬야하는 부분이다.그래서 useMe라는 별도의 HOC를 만들어 쿼리를 리턴시키는 용도로 사용하고있다.2. 유저 인증을 위한 hook사실 코드만 보면 진짜 별 것 없이 간단한 코드인데 next js에 별도로 apollo가 얹어있는 세팅을 진행하다보니 몇가지 문제가 발생했었다.1번의 세팅에서 보이듯 아폴로서버가 최상단에 존재하므로 next js 기반에서 두가지 경우 localStorage의 값을 보고 업데이트가 되었다. 앱이 최초 빌드될때 refresh가 일어나서 처음부터 렌더가 되는 시점을 제외하고는 별도로 apollo를 위해 세팅해준 값이 apolloClient.ts내에서 변경되지 않는 문제가 있었다.import { useLazyQuery, useQuery } from &quot;@apollo/client&quot;;import { ME_QUERY } from &quot;../graphql/queries&quot;;import { meQuery } from &quot;../src/__generated__/meQuery&quot;;export const useMe = () =&amp;gt; { return useQuery&amp;lt;meQuery&amp;gt;(ME_QUERY);}; UseMe.tsx세팅을 조금 더 설명하자면 useReactiveVar는 typePolicies에 미리 설정해준 fields의 값에 해당하는 값이 들어간 query들을 다시 한번 refresh할 용도로 사용하려했다.(그리고 추가적으로 apollo.ts의 변수값도 곧바로 변경이 될 줄 알았다 ㅎ…)일단 여기까지는 작동을하였고 헤더에서 로그인이 되지않은 경우 로그인 버튼을, 로그인 된경우 로그인 된 유저의 프로필사진을 보여주는 기능을 구현하는 것에 문제가 없었다.문제는 유저의 프로필 사진이 나타나는 시점이었다.즉 초기 렌더시 서버사이드로 진행되는 경우 apollo.ts에 설정된 localStorage와 관련된 값인 isTokenVar또는 isLoggedInVar를 사용할 수 없게 되어 에러가 발생하였고 이걸 해결하는 것이 필요했다.아래는 apollo.ts로 apollo-client를 설정하는 파일이다.const token = typeof window !== &quot;undefined&quot; ? localStorage.getItem(&quot;folks-token&quot;) : &quot;&quot;;export const isLoggedInVar = makeVar(false);export const authTokenVar = makeVar(token); //요주의 인물const httpLink = createHttpLink({ uri: &quot;http://localhost:4000/graphql&quot;, headers: { &quot;folks-token&quot;: authTokenVar() || &quot;&quot;, },});function createApolloClient() { return new ApolloClient({ ssrMode: typeof window === &quot;undefined&quot;, link: httpLink, cache: new InMemoryCache({ typePolicies: { Query: { fields: { token: { read() { return authTokenVar(); }, }, isLoggedIn: { read() { return isLoggedInVar(); }, }, allPosts: concatPagination(), }, }, }, }), });} apolloClient.ts그래서 이런 설정을 활용하며 원하는 요구조건을 실행하기 위해서문제와 해결방법의 정리를 위한 사고흐름을 정리 해보았다. 로그아웃 후 다른 아이디로 로그인시 토큰은 변경되었으나 Header의 프로필은 그전의 아이디의 값이 존재했음 중간에 redux toolkit을 다른 이유로 설치하고 편하게 관리하기 위해 user를 별도로 글로벌 State로 활용한것이 설마 문제가 있을까 하여 다 걷어냄 현상이 유지가 되어서 next js의 문제 인지 apollo의 캐시인지 확인이 필요했음 apollo devtool 확인결과 애초에 최초로그인 시에는 cache에 저장되지도 않았음 -&amp;gt; 데이터가 안들어온 것. -&amp;gt; 네트워크 헤더에 토큰값 비어있음.. 조금 더 살펴보니 로그인 직 후 profile에서 변경된 makeVar로 만든 토큰값은 변경되어있지만 apollo client는 이미 세팅된 직후라 변경되지 않음 -&amp;gt; 그래서 요청때 비어있음. 또다른 문제는 최초 로그인 후 다른 아이디로 로그인시 새롭게 query가 호출이 되지 않음 client.resetStore()를 하라는 공식문서 따라 해보려했으나 next js에서는 아폴로를 인스턴스로 가져와서 사용해야하기 때문에 쿼리가 그냥 다깨짐그래서 작동이 안되었음, 그래서 clearStore =&amp;gt; resetStore로직이 편하게 먹질 못함 readQeury를 사용해 로그아웃일때 writeQuery를 사용해서 해당 쿼리의 유저값을 비워주려했음 -&amp;gt; 적절하게 사용할 곳이 아님 -&amp;gt; 공식문서 더 봐야함찾아보니 wrtieFragment와 readQuery의 조합으로 쓰면 될 것 같음 -&amp;gt; 생각해보면 무조건 관련 세팅이 있을 것 같음 모두가 이렇게 긴 쿼리를 쓰며 시간을 낭비하지 않을 것 같음. 역시 .. useQuery에 세팅을 할 수가 있음위 사고흐름을 통해 공식문서를 찾아보니 ..너무나도 당연하게 관련 세팅이 있었고쿼리의 세팅은 이렇게 바뀌었다.const [getMeInfo, { data, error, loading }] = useLazyQuery&amp;lt;meQuery&amp;gt;(ME_QUERY, { context: { headers: { &quot;folks-token&quot;: typeof window !== &quot;undefined&quot; ? localStorage.getItem(&quot;folks-token&quot;) : &quot;&quot;, }, }, nextFetchPolicy: &quot;network-only&quot;,});꽤 복잡(?)해졌으나 크게 두가지 문제를 모두 해결하게 된 방법이다1번 문제였던 캐싱된 데이터가 업데이트 되지 않던 현상 =&amp;gt; nextFetchPolicy를 통해서 캐시를 사용하지 않고 매번 네트워크 요청을 만드는 것2번 문제였던 헤더에 localStorage에 있는 정보를 사용해야 할 경우 apollo.ts에서 설정해준것이 반영되지 않던 현상 -&amp;gt; context에 직접 주입을 통해서 해결하였다.어떻게보면 정말 간단하고 당연한(REST API 짱.. 익숙한게 최고.. 읍읍) 접근법일 수 있으나SSR과 query방식의 데이터 호출을 제대로 사용해보려고 한 것은 처음이라 문제점을 찾는 과정까지도 시간이 좀 걸린 것 같다.이 외에도 lazyQuery를 쓴 이유는 앱이 렌더되는 시점은 useEffect에서 해당 쿼리를 부르기 위해서이다.3. 결론기본적으로 프로젝트를 진행하는데에 있어 프론트 부분에서 중요하다고 생각한 유저의 데이터 활용 및 Auth 관련문제를 해결하게 되었다.뭔가 어이없게 설정 몇개로 해결된 것에 있어 사고과정을 진행한 시간이 아깝다 생각이 들기도 하고 그렇다..주니어를 벗어나기가 쉽지않다.추가로 SSR은 유저들이 작성한 게시글을 뿌려줄때 쿼리를 이용해 받은 포스트번호를 써서 활용할 수 있을 것 같다.(이러면 애초에 보안상 큰 문제도 없을것 같다.)다음편은 Toast UI를 통해 Editor를 가져오는 방법을 다른 멋진분의 블로그를 통해 구현한 일부분을 포스팅해보겠다.끝참고 Queries - Fetch data with the useQuery hook Nextjs Docs - Authentication" }, { "title": "Jest, Cypress로 FE를 테스트해보자", "url": "/posts/FETest/", "categories": "FE, Jest, FE Test, Cypress", "tags": "Jest, FE Test, Cypress, msw", "date": "2021-10-03 12:33:00 +0900", "snippet": "1. 시작하게 된 이유사내에서 앱의 크기가 방대해지며 전체적인 구조를 비즈니스로직과 뷰로 나누는 작업을 진행하였다.이 과정에서 상수, 반복문, interface등의 타입정의를 나눴고 적지 않은 변화가 발생하며 기존에 잘 작동하던 코드가 실제로 원하는 방식으로 작동하는지 확인해보기 위한 검증이 필요하였다.그래서 그 기회를 통해 FE테스트를 도입해보자! 라는 패기로운 생각과 함께 여러가지 자료를 찾으며 삽질을 하였고..정화된 결과를 정리하는 글을 써보자 생각하여 글을작성한다.2. 개념 (Unit, Integration, E2E)사실 처음 시작할때는 Jest라이브러리의 존재말고는 친숙하지 않아 개념을 잡는것에 많이 해맸었다.백엔드의 테스트 같은 경우 req, res로 요청과 응답이 일정한 반면,프론트의 경우 유저 이벤트 -&amp;gt; 이벤트 발생 -&amp;gt; 화면변경으로 흐름을 생각할 수 있지만 백엔드와는 다르게 UI가 변화하는 것과 동시에 통신응답이 있는경우가 존재하기도 하고UI의 특별한 변화 없이 통신만을 하는 경우도 있기때문에 명확한 기준 설정이 필요했다.특히 프론트단에서의 Unit테스트와 Integration Test의 범위를 어떤방식으로 나뉘어야 효과적일지에 대해 고민이 많이 들었고2019-실용적인프론트엔드 테스트 전략를 통해 각 테스트의 경계부분을 설정하는 것에 많은 도움이 되었다.현재 재직하고 있는 회사의 Tech Stack은 react, redux-toolkit, redux-saga, styled-component로 프론트가 구성되어있고각 API, constant, util들은 분리가 되어 있으며 페이지 마다 그 분기를 가져가고 있다.(이렇게 분리하느라 고생을 많이했다 ㅎ…)2.1 Redux-toolkit Unit Test가장 간단한 단위로서 현재 회사의 TechStack 중 redux-toolkit에 존재하는 로직 및 복잡한 util 함수에 한해서 매우 복잡도가 높은 경우만 해당 테스트를 진행하기로 했다.이렇게 정한 이유는 애초부터 test coverage를 높이는 것이 목적이 아닌 경력이 짧은 개발자들로 구성된 팀에서 최소한의 방어장치를 위해 접목한 것이기 때문이다.쉽게 말하면 아래의 목적을 위해서만 Unit Test를 실행하려 했다. 실수로 불완전한 복잡한 로직을 프로덕트에 배포하는 불상사를 방지하는 목적 다른 개발도 진행해야하기때문에 테스트코드 작성에 최소한의 시간 투자에 최대한의 효율을 끌어내는 목적describe(&quot;근무유형등록 &amp;gt; 고정형 &amp;gt; Select option 조건에 따라 state변경&quot;, () =&amp;gt; { afterEach(() =&amp;gt; { reducer(initialState, initialSetting()); }); describe(&quot;handleFixAttendStartTime&quot;, () =&amp;gt; { test(&quot;시간타입 변경 시 퇴근시간은 시작시간 + 9로 변경됨&quot;, () =&amp;gt; { expect( reducer( initialState, handleFixAttendStartTime({ timeType: &quot;hour&quot;, value: &quot;10&quot; }) ) ).toEqual({ ...initialState, attendTime: &quot;1000&quot;, leaveTime: &quot;1900&quot; }); }); test(&quot;분 타입 변경 시 출근시간과 동일한 분을 가지게 됨(00분 또는 30분)&quot;, () =&amp;gt; { expect( reducer( { ...initialState }, handleFixAttendStartTime({ timeType: &quot;minute&quot;, value: &quot;30&quot; }) ) ).toEqual({ ...initialState, attendTime: &quot;0930&quot;, leaveTime: &quot;1830&quot; }); }); });});위 코드와 같이 해당하는 reducer, action creator를 가져와서 정해놓은 로직에 따라 기대한 state를 반환하는지 테스트 하였다.afterEach를 사용하여 각 테스트가 진행되기 전 state값을 초기화 하여 상호 테스트 간에 영향이 없도록 만들었다.util과 같은 간단한 함수도 유사한 방식으로 진행하였고 실제 근무중인 인사, 법령과 관련된 UI,UX에서는 조건에 따라 분기 처리되는 로직이 많아쓸데없는 자신감을 가지기에 유용한 테스트였다고 생각한다.2.2 Redux-saga Unit Test사실 테스트에 대해 거의 모르는 상황에서 테스트를 무작정해봐야겠다고 처음 시도했던 것이 redux-saga쪽이었다.운이좋게도 가장 직관적인 테스트방법이었던 것 같아 참 다행이라고 생각된다.아래에서 한번 더 언급하겠지만, 해당테스트에서는 API가 제대로 호출되는지 call 메서드를 통해 확인이 가능하므로액션이 순서에 맞춰 호출이 되는지 + Saga가 API함수를 적절하게 호출하는지에 대한 개념으로 테스트를 커버하였다.it(&quot;로딩시작 ,모든 구매 이용권 데이터를 받아오는 API 호출, 데이터 voucher slice에 저장,로딩 끝&quot;, () =&amp;gt; { expect(iterator.next().value).toEqual(put(setIsLoading(true))); expect(iterator.next().value).toEqual(call(getSubscriptonData)); expect(iterator.next(mockedResponseData).value).toEqual( put(saveSubscriptionData(mockedResponseData.data)) ); expect(iterator.next().value).toEqual(put(setIsLoading(false))); expect(iterator.next().done).toBeTruthy();});generator의 특징이 활용되어 next의 value를 알 수 있게 되어 해당방식을 통해 액션의 값 변화를 살펴볼 수 있게 된다.다만 처음에 next안에 들어가는 값의 용도를 몰라 헤매었던 기억이 있는데 다음 iterator 즉 yield가 선언되어있는 곳에서 받을 값을 미리 대신한다고 보면 된다.3 Integration TestIntegration Test는 초기에는 testing-library와 jest의 조합만 활용하여 DOM snapshot의 클래스명을 통해 이를 확인해볼까 생각을했다.(많은 기존의 영상들이 이러한 방식을 보여줬다.)하지만 styled-component로 만들어지는 스타일 컴포넌트가 대부분이므로 Hashing된 클래스명으로 이를 판단하기에는 무리가 있었기 때문에 다른 방식이 필요했고무엇보다 실제화면이 아닌 DOM만으로 이것이 정확하게 작동하고 있는지 판단하기에는 무리가 있다고 판단하였다.그래서 여러가지 방식을 찾아보고 강의도 들어본 뒤, Cypress를 통해 실제 UI의 변경사항을 보면서 테스팅을 가능한 방식으로 진행하였다.API 호출의 경우 cypress에서 기본적으로 fixture를 활용하여 mocking-response를 반환해주는 메서드가 존재하나,실제 서버에 데이터를 전송하고 받아온 데이터를 모킹하는 방식이므로 비효율적이라고 판단하였고동시에 Integration Test보다는 E2E테스트와 유사하다고 보이기 때문에 실제 api request, response 모두를 모킹할 수 있는 라이브러리인 msw를 선택하여 사용하였다. rest.get(`${VACATION_PREVIEW_URL}`, (req, res, ctx) =&amp;gt; { const monthType = req.url.searchParams.get(&#39;monthType&#39;); const yearType = req.url.searchParams.get(&#39;yearType&#39;); const enterDate = req.url.searchParams.get(&#39;enterDate&#39;); let newdateData = [...dateData]; const len = newdateData.length; if (monthType === &#39;BEFORE&#39;) { newdateData.splice(len - 1, 1, { ...dateData[len - 1], yearRemark: monthType === &#39;BEFORE&#39; ? &#39;1번째 회계일&#39; : null, monthRemark: monthType === &#39;BEFORE&#39; ? null : &#39;4개월차&#39;, }); } if (yearType) { newdateData.splice(0, 1, { ...dateData[0], yearRemark: yearType === &#39;ACCOUNT_FULL&#39; ? &#39;회계일&#39; : &#39;입사일&#39;, }); } if (enterDate) { newdateData = newdateData.map((el, index) =&amp;gt; ({ ...el, date: `2021-${ Number(newdateData[0].date.split(&#39;-&#39;)[1]) + index }-${String(enterDate).slice(-2)}`, })); } return res(ctx.json([...newdateData])); }), handler.ts위 코드와 같이 조건등에 따라 마음대로 msw를 설정할 수 있고 실제로 요청을 하지 않으므로 완벽히 프론트 단에서 원하는 상황에 대한 테스트를 할 수 있게 된다.다만 굉장히 공수가 많이 들어갔고 실제로 많은 부분을 이런방식으로 테스트하기위해서는 실제 개발과 유사할 정도로 노력이 필요한 것 같다는 판단을 했다.(아직 익숙치 않아서 그런것 같기도하다..)describe(() =&amp;gt; { it(&quot;모달에 내용 변경 뒤 나가기 버튼 클릭 후 다시 열었을때 내용 초기화&quot;, () =&amp;gt; { user.findAllByText(&quot;설정&quot;).click(); user.findAllByText(&quot;입사자 월차&quot;).siblings().click(); user.get(&quot;ul&quot;).find(&quot;li&quot;).contains(&quot;입사일에 11개 선 지급&quot;).click(); user.findAllByText(&quot;입사일에 11개 선 지급&quot;).should(&quot;exist&quot;); user.findAllByText(&quot;나가기&quot;).click(); user.findAllByText(&quot;설정&quot;).click(); user.findAllByText(&quot;1달만근 시 1일 지급&quot;).should(&quot;exist&quot;); });}); sth.integration.tscypress의 경우 위에 작성된 방식처럼 특수하게 중복될 일 없는 텍스트를 통해서 테스트를 위한 dom에 접근하여 click이벤트 및 존재여부 확인등을 쉽게 판단할 수 있게 된다.다만, 공식문서에는 그리 추천하지 않고 data-id 등을 통해서 테스트를 위한 아이디값을 미리 설정하고 확인하는것을 추천한다고 되어있어추후에 테스트코드를 한번 리팩토링 할 때, 다른방식을 시도해볼 생각이다.4. E2E Test사실 integration test와 e2e테스트에서 차이점을 준 것은 백엔드와의 연동이 되느냐 마느냐의 문제로 나뉘었다.프론트엔드 특성 하나의 유저 이벤트를 통해 다양한 API호출이 발생하고 화면이 변경되고 하는 일이 많아 페이지별로 integration test를 진행하고모든 작동이 정상적으로 된다면 이벤트를 통해 API를 호출하는 등의 행동에 대한 안정성이 커버된다고 판단했기 때문이다.또한, Timing-difference로 인해 클릭이벤트로 인한 호출 순서에 대한 확인이 필요하거나 호출 횟수가 의도한대로 발생하는지에 대해 확인하기 위해서는 별도로toHaveBeenCalled() 와 같은 메서드를 통해 확인해주거나, 실제 테스트가 진행되는 동안 모든 로그가 찍히기때문에 직접 확인해보는 방법이 있어 이를 활용하였다.여기서 변수는 위에서 언급한대로 테크스택이 리덕스 툴킷 + 리덕스사가로 이루어져있어 api의 대부분의 호출은 redux saga를 통해 진행되는데이때 cypress에해서 해당 api가 호출되었는지 확인이 되지 않아 굉장히 애를 먹었고 보장하는 범위를 생각하여 다시 테스트를 구성하였을 때는 합리적인 구성이 나왔다. Integration Test에서는 redux toolkit+ redux saga의 해당 action이 실행되는지 확인한다. Unit Test에서 Redux saga를 테스트하여 해당 API를 호출하는지 확인한다.위와 같은 방식으로 구분을 지어놓고 난 뒤 테스트를 더욱 간편하게 짤 수 있게 되었다.describe(&quot;companyId와 userName이 있고 토큰이 없는 경우&quot;, () =&amp;gt; { it(&quot;로그인 정상작동 및 해당 경로로 정상이동&quot;, () =&amp;gt; { const to = &quot;vouchers&quot;; user.login({ to }); user.window().its(&quot;store&quot;).invoke(&quot;dispatch&quot;, doLogin); user.location(&quot;href&quot;); user.location().should((location) =&amp;gt; { expect(location.href).to.eq(`http://localhost:3000/${to}`); }); });}); redirect.e2e.ts위의 reidrect.e2e.ts에서처럼 window에 미리 Cypress가 존재하는 경우에만 store객체를 임의로 배정준 뒤그것을 통해서 store의 변동사항 및 액션이 dispatch되는지 확인할 수 있게 된다.cypress-pipe라는 별도 모듈을 설치하면 payload와 state의 변동사항도 체크할 수 있다.5. 결론입사 후 주니어 프론트개발자 분밖에 계시지 않아 (물론 나도 주니어이다.) props drilling을 통해 급하게 jsp에서 포팅된 코드들로 이루어진 리액트 프로젝트였다.그 과정에서 유틸,상수,api분리를 위한 redux-saga도입을 통해 관심사를 최대한 분리하려 하였고 유지보수가 용이하게 만들기 위해 노력했다.그리고 마지막으로 조금이라도 마음이 편해져보고자(+ 알아야만 하는) FE Test에 대한 개념을 공부하며 회사에 도입하며 혼자 애를 굉장히 먹으며 진행했다.하지만 여러가지 개념을 배우게 되었고(테스트 개발의 개념 등..), 설계를 어떤방식으로 하는게 유리할지에 대해 다양한 시각에서 생각을 해보게 되어 굉장히 값어치 있는 시간이었다고 생각된다.아래 참고에는 무수히 참고한 많은 포스팅중 나름 필요하다고 생각된 것들을 별도로 노션에 모아놓았던 것인데 누군가에게는 도움이 될지 모르겠지라는 마음으로 다 공유해본다.아마도 이글을 포스팅하고 나서도 추가적으로 수정을 몇번씩 할 것 같다,끝!참고Concept [2019] 실용적인 프런트엔드 테스트 전략 리액트 테스트의 소개 실용적인 프론트엔드 테스트 전략 (1) : NHN Cloud Meetup 실용적인 프론트엔드 테스트 전략 (2) : NHN Cloud Meetup 프론트엔드 테스트의 모든 것Library Usage Test Coverage를 유지하는 방법 The Delightful Storybook Workflow react-testing-library 를 사용한 리액트 컴포넌트 테스트 react-testing-library 를 사용하여 TDD 개발 흐름으로 투두리스트 만들기 React Integration Testing with React-testing-library React Testing Library 사용법For Testing API with action dispatched with redux toolkit Unit Testing Sagas with Jest https://www.youtube.com/watch?v=OVNjsIto9xM&amp;amp;t=1545sMocking API with JEST https://www.youtube.com/watch?v=RYQE5X6lhis [Jest] jest.fn(), jest.spyOn() 함수 모킹msw Docs msw Getting Started with Mock Service WorkerTips Avoid Nesting when you’re Testing Static vs Unit vs Integration vs E2E Testing for Frontend AppsJest Setting for MonoRepo Configuring Jest · Jest Jest + SCSS @import issue (css modules) How to make jest tests that involve components imported from other packages? · Issue #2341 · lerna/lerna" }, { "title": "Next JS를 공부해보자[1편]", "url": "/posts/nextjs_basic/", "categories": "FE, Next JS", "tags": "Next JS", "date": "2021-09-29 12:33:00 +0900", "snippet": "Next JS사용하는 이유개인 프로젝트로 재미있는 기능이 몇가지 존재하는 커뮤니티 사이트를 만들어볼 생각으로백엔드는 Nest JS + TypeORM + Postgresql + Graphql/apollo프론트는 CRA + Redux Toolkit + Redux Saga로 진행하려 초기세팅을 마쳤었다.Express로 간단하게 데모를 만들어본 뒤로는 NestJS만을 통해 필요한 서버를 구축하고 있는 상황이라 백엔드는 NestJS이외에 마땅한 대안이 떠오르지않았는데..(아무래 생각해도 최고다)프론트의 경우 SEO와 SSR, CSR을 번갈아 쓸 수 있는 Next js의 유혹을 뿌리칠 수 없었고무엇보다도 시장에서 수요가 꽤 있어 언젠가는 해야지 하는 생각을 가지고 있었다….회사에서 쓰는 스택을 포기하고 NextJS와 SSR의 조합으로 진행하고 테스트 코드의 경우 Jest, MSW, Cypress, StoryBook을 가져가는게 맞는 것 같다고 판단을 내렸다. 사실 Cypress는 회사에서 직접 도입하며 문제를 해결해보아 그나마 괜찮으나 Storybook은 조금 걱정이다여튼 커뮤니티의 유저를 늘리기 위해서는 SEO가 불가결할 것 같아 시도하게되는 Next JS이다 :) …아래부터는 내가 진행하면서 헷갈리는 개념을 몇가지 정리해놓기 위한 포스팅의 목적이 크다!1. 개념1.1 CSS, Router일단 기본적으로 css in js 스타일링도 지원되고 scss, css등이 모두 정해진 위치(assets, pages, components 등)에 잘 두면 작동이 간편하게 된다.이 맛에 프레임워크를 쓴다 ㅎㅎ…공식문서에 있는 그대로 따라하면 좋은 것 같다. 나는 class toggle이 용이해보이는 classnames라는 패키지모듈을 별도로 설치해 사용하고나머지는 scss와 css를 util화 하여 적절하게 사용하는 것이 좋다고 판단하고 있다.1.2. Static Generation vs Server Side RenderingNext js에서는 아래 두 컨셉을 페이지별로 필요에따라 마음대로 선택하여 사용할 수 있다.1.2.1 Static Generation HTML을 빌드타임에 미리 렌더링시키는것(pre-rendering) 미리 렌더된 HTML은 각 요청마다 재사용되게 된다. 개발모드에서는 Static Generation이라 하더라도 Server-side Rendering와 같이 각 요청(Request)마다 새롭게 생성 유저의 요청전에 필요한 페이지인 경우 마케팅 페이지 블로그 게시물(이래서 쓴다) E-commerce 제품 리스트 문서나 문서 데이터를 미리 받아오는 등의 전처리가 필요한 경우 getStaticProps 라는 함수 안에서 필요한 로직을 실행하면 된다.1.2.2 Server-side Rendering 각 요청마다 새로운 HTML을 생성해준다 별도 설정없이은 CDN캐시가 되지 않고 매 요청마다 서버에서 새로 계산을 해야하므로 시간이 getStaticProps에 비해 더 걸리게 된다. 매 요청에(request time)에 데이터를 가져와야 하는경우(빌드타임이아닌고 렌더 되기 전에 이미 완성이 되어있어야 하는 경우) getServerSideProps 를 사용하면 된다. When you need to fetch data at request time instead of build time You should use getServerSideProps only if you need to pre-render a page whose data must be fetched at request time. Time to first byte (TTFB) will be slower than getStaticProps because the server must compute the result on every request, and the result cannot be cached by a CDN without extra configuration.1.2.3 Client-side Rendering 데이터를 pre-rendering할 필요가 없고 정적으로 미리 만들어진 사이트가 외부데이터를 필요로 하지 않을때 정적페이지가 로딩 된 다음 외부 데이터를 client의 js사용으로 나머지 부분을 채우게 만드는 방법 게시판 페이지등에 활용 dashboard는 유저의 개인 공간이기 때문에 SEO(검색엔진 최적화)가 필요가 없으므로 pre-render가 필요하지 않음 데이터가 수시로 업데이트되는 경우 활용하기1.3 SWR Client side에서 데이터를 받아오기 위해 사용하는 Hook임 It handles caching, revalidation, focus tracking, refetching on interval, and more. 2. 활용2.1 Static GenerationStatic Generation의 샘플이다.getStaticProps를 적용하고 간단하게 만든 REST API를 통해 데이터를 미리 받아온다.HTML을 빌드타임에 렌더링시킨 뒤 보내게 된다.재미있는 부분하나 utilStyle.headingMd등 약간 모듈같이 css를 활용할 수 있게 된 점이다.import axios, { AxiosResponse } from &quot;axios&quot;;import Head from &quot;next/head&quot;;import Link from &quot;next/link&quot;;import Layout, { siteTitle } from &quot;../components/layout&quot;;import utilStyles from &quot;../styles/utils.module.css&quot;;// 예시로 필요한 데이터를 보내기 위해 간단한 RESTAPI를 만들어 사용interface DataTest { date: string; title: string; content: string;}interface TestData { returnData: DataTest[];}const Home = ({ returnData }: TestData) =&amp;gt; { return ( &amp;lt;Layout home={true}&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;{siteTitle}&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;Link href=&quot;/posts/first-post&quot;&amp;gt; &amp;lt;a&amp;gt;To go first Post&amp;lt;/a&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;section className={utilStyles.headingMd}&amp;gt; &amp;lt;p&amp;gt;Hello There&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;This is Sample Website&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;a href=&quot;https://nextjs.org/learn&quot;&amp;gt;our Next.js tutorial&amp;lt;/a&amp;gt;. &amp;lt;/p&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section className={utilStyles.headingMd}&amp;gt; &amp;lt;ul&amp;gt; {returnData?.map((el) =&amp;gt; ( &amp;lt;li key={el.date}&amp;gt; {el.date} &amp;lt;br /&amp;gt; {el.title} &amp;lt;br /&amp;gt; {el.content} &amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/Layout&amp;gt; );};//https://nextjs.org/learn/basics/data-fetching/getstaticprops-detailsexport async function getStaticProps() { const { data }: AxiosResponse&amp;lt;{ data: TestData }&amp;gt; = await axios.get( &quot;http://localhost:4000/images/test&quot; ); const returnData = data.data; return { props: { returnData, }, };}export default Home; getStaticProps 예시2.2 Server-side Renderingimport axios, { AxiosResponse } from &quot;axios&quot;;import { GetServerSideProps, InferGetServerSidePropsType } from &quot;next&quot;;import Head from &quot;next/head&quot;;import Link from &quot;next/link&quot;;import Layout from &quot;../../components/layout&quot;;import utilStyles from &quot;../../styles/utils.module.css&quot;;interface DataTest { date: string; title: string; content: string;}interface TestData { data: DataTest[];}const FirstPost = ({ data,}: InferGetServerSidePropsType&amp;lt;typeof getServerSideProps&amp;gt;) =&amp;gt; { return ( &amp;lt;Layout home={false}&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;First Post!&amp;lt;/title&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;h1&amp;gt;First Post!&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt; &amp;lt;Link href=&quot;/&quot;&amp;gt; &amp;lt;a&amp;gt; Back to HOme&amp;lt;/a&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;/h2&amp;gt; &amp;lt;section className={utilStyles.headingMd}&amp;gt; &amp;lt;ul&amp;gt; {data?.map((el: DataTest) =&amp;gt; ( &amp;lt;li key={el.date}&amp;gt; {el.date} &amp;lt;br /&amp;gt; {el.title} &amp;lt;br /&amp;gt; {el.content} &amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/Layout&amp;gt; );};export const getServerSideProps: GetServerSideProps = async (context) =&amp;gt; { const res: AxiosResponse&amp;lt;{ data: TestData }&amp;gt; = await axios.get( &quot;http://localhost:4000/images/test&quot; ); const data = res.data.data; if (!data) { return { redirect: { destination: &quot;/&quot;, permanent: false, }, }; } return { props: { data }, };};export default FirstPost;3. 결론기본적으로 필요한 CSS, REST-API 받는방식 및 관련 개념을 정리해보았다.SWR같은경우는 세팅을하고 컴포넌트를 작성하면서 다시한번 샘플을 해당 포스팅에 남겨보아야겠다.이제 다음편에 해야할 것은 이 링크를 통해 apollo-client를 연결하여graphql/ apollo/ apollo-client을 세팅하는 방법을 공부하며 포스팅해보겠다참고 Fetching Data at Request Time getStaticProps Details" }, { "title": "Webpack과 React를 사용하여 Custome Element 만들기[3 - 커스텀엘리먼트 렌더]", "url": "/posts/webpack3/", "categories": "FE, Webpack", "tags": "Webpack", "date": "2021-09-24 12:33:00 +0900", "snippet": "커스템 엘리먼츠1. 서론앞서 2편을 통해 웹팩 세팅을 하며 모든 파일을 하나의 js파일로 번들링할 수 있게 되었다.그래서 마지막 rendering에 관한 로직만 추가하면 마지막 스텝이 마무리가 된다!기존에 회사에서 사용하던 컴포넌트집합들 중 일부를 하나의 js파일로 번들링하여외부에서 해당 커스텀엘리먼츠를 선언하고 script태그를 통해 번들링 된 파일을 받아오기만 하면 요구사항을 구현할 수 있게 될 것 같았다.2. 방식일단 기본적으로 React는 가상의돔인 ReactDOM을 사용하고 기존 ReactDOM.render()메서드는 지정된 node엘리먼트에 번들링 된 결과물을 연결하게 되는 방식이다.그래서 기존의 render메서드를 좀 손볼 필요가 있어 여러 자료들을 서치하였다.좋은 샘플을 발견하였고 구체적인 작동방식 설명이전에 간단한 설명을 크게 세가지 단계로 나뉘어서 이야기할 수 있다. 사용할 커스텀태그를 새롭게 document에 만든다 ReactDOM.render메서드를 활용해 루트컴포넌트를 document에 새로만든 커스텀태그에 가상돔으로 렌더시킨다. 외부 html의 script에서 React에 미리 선언된 이벤트를 사용하고 콜백함수로 덮어씌울 수 있어야하므로 dispatchEvent를 사용하였다.2.1 1단계 CompProps는 컴포넌트가 가지게 될 props이다 document.createElement를 통해 document에 tag이름을 가진 커스텀엘리먼트를 미리 만들어둔다 기존 컴포넌트에서 사용하는 react portal을 위해 modal이라는 id를 가진 div도 만들어준다. nodes라는 변수에 커스텀엘리먼트로 만든(여러번 선언할 수도 있으니까)태그를 가져와서 배열에 담아준다. 이어서 2단계!// custom tagsfunction render(tag: string, Comp: React.FC&amp;lt;CompProps&amp;gt;) { document.createElement(tag); //for modal const modal = document.createElement(&quot;div&quot;); modal.setAttribute(&quot;id&quot;, &quot;modal&quot;); document.body.appendChild(modal); // const nodes: Element[] = Array.from(document.getElementsByTagName(tag)); nodes.map((node, i) =&amp;gt; renderNode(tag, Comp, node, i)); return Comp;}render(&quot;test-home&quot;, App);2.2 2단계 Array.prototype.slice.call()을 이용하여 node.attributes에 존재하는 객체{key:value}들의 을 카피한 배열로 반환해준다.(이렇게하면 얕은복사가 진행되므로 node에 직접 추가가 가능 해진다.) 커스텀앨리먼츠에 선언한 props를 리액트에서 활용하기 위해 props라는 변수에 임의로 {key:value}에 해당하는 것을 선언해주고 node.attributes의 속성으로부터 props로 선언한 값을 가져온다. 커스텀엘리먼츠가 class이름으로 받은 이름을 리액트에서 className으로 사용하기 위해 처리를 별도로 해준다. 가상돔에 해당 컴포넌트와 props를 렌더하고 1단계에서 만든 커스텀엘리먼트에 렌더가 된다. 여기까지하면 커스텀이벤츠는 사용하지 않고 엘리먼트로 필요한 컴포넌트를 렌더할 수 있게된다.interface IAttrs { [key: string]: string;}interface IProps extends CompProps { [key: string]: string | undefined;}function renderNode( tag: string, Comp: React.FC&amp;lt;CompProps&amp;gt;, node: Element, i: number) { let attrs: IAttrs[] = Array.prototype.slice.call(node.attributes); let props: IProps = { key: `${tag}-${i}`, }; attrs.map((attr) =&amp;gt; { return (props[attr.name] = attr.value); }); if (!!props.class) { props.className = props.class; delete props.class; } ReactDOM.render(&amp;lt;Comp {...props} /&amp;gt;, node);}2.2 3단계이제 커스텀한 이벤트를 외부에서 필요한 로직으로 활용할 수 있게만 만들어주면 된다. js에서 지원하는 CustomeEvent 클래스를 활용해 컴포넌트 내부에서 미리 선언해주고 커스텀이벤트에서 props로 받을 id에 해당 이벤트를 걸어준다 dispatchEvent 메서드를 활용하여 해당 커스텀 이벤트를 컴포넌트 내부에서 필요한 부분에 실행해준다. 외부 html에서 해당 이벤트에 eventListener를 걸고 콜백함수로 필요한 로직을 실행하면 된다.아래는 컴포넌트에서 선언하여 필요한곳에 배치한 코드이다.import React from &quot;react&quot;;import { HomeCompProps } from &quot;../../model/types&quot;;import &quot;../../styles/sass.scss&quot;;const Home: React.FC&amp;lt;HomeCompProps&amp;gt; = (props) =&amp;gt; { const wrapper = document.getElementById(props[&quot;id&quot;]); const newCustomEvent = new CustomEvent(&quot;onOpen&quot;); const openModal = () =&amp;gt; { wrapper?.dispatchEvent(newCustomEvent); console.log(props[&quot;id&quot;]); }; return ( &amp;lt;div className=&quot;testWrapper&quot;&amp;gt; &amp;lt;section&amp;gt; &amp;lt;img onClick={openModal} className=&quot;img-home&quot; src=&quot;https://&quot; alt=&quot;home-file-loader&quot; /&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/div&amp;gt; );};export default Home;아래는 외부 html에서 필요한 로직을 콜백으로 구현한 것이다.&amp;lt;body&amp;gt; &amp;lt;test-home id=&quot;test&quot; user-id=&quot;test&quot;&amp;gt;&amp;lt;/test-home&amp;gt; &amp;lt;script src=&quot;https://s3.blahblah.test.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot; defer&amp;gt; const dtime = document.getElementById(&quot;dtime&quot;); dtime.addEventListener(&quot;onOpen&quot;, () =&amp;gt; alert(&quot;index.html script alert&quot;)); // 기존 onOpen 실행 event 그대로 유지 &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;3. 결론커스텀엘리먼트를 만들기 위해 다시한번 DOM, Node, VirtualDOM에 대해 많이 찾아보게 된 것 같다.기존에 회사의 모든 프로젝트들이 SPA로 되어있어 웹팩을 해야지 해야지.. 하던 생각이 있었는데 좋은기회에 기본적인 것을 공부할 수 있게되어 개인적으로는 매우 보람차다!아무쪼록 회사 내부의 사정이 잘 해결되어 커스텀엘리먼츠를 더욱 활용하며 조금 더 깊은 공부를 할 수 있는 기회가 많아지면 좋겠다 :)참고 Talk to your React components with custom events github issue-dispatchEvent customEvent of web components not working codepen-BradDenver BSIDESOFT co. - [js] Array.prototype 사용하기 제로초님 블로그-객체의 복사" }, { "title": "Webpack과 React를 사용하여 Custome Element 만들기[2 - 웹팩(플러그인)]", "url": "/posts/webpack2/", "categories": "FE, Webpack", "tags": "Webpack", "date": "2021-09-18 12:33:00 +0900", "snippet": "Webpack1. 사용한 플러그인(plugins)플러그인은 번들된 파일을 처리하기 위해 사용하는 것이다.각 플러그인의 개념은 간단하게 적고 넘어가겠다.1.1 CleanWebpackPlugin이 플러그인은 출력 Path(output)으로 정해놓은 것의 모든파일을 지워주고 리빌드 완료 후 사용되지않는 이미지 파일등의 webpack assets을 모두 지워준다.1.2 HtmlWebpackPluginhtml파일을 후처리하는데 사용된다. 이 플러그인으로 빌드 시 html파일로 아웃풋에 생성이 된다.{ plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }) ],}1.3 ReactRefreshWebpackPlugin새로고침에도 리액트 컴포넌트가 hot-reload 가 되기 위해 사용한 plugin이다.나는 설정 cross-env 를 이용하여 스크립트 작동 시 isDevelopment 변수가 true가 될 때 해당 플러그인을plugins라는 배열에 push해주는 방식을 택했다.아래 코드는 위에 언급된(1.1~1.3)모든 플러그인들이 적용되는 방식을 보여주는 예제이다.const ReactRefreshWebpackPlugin = require(&quot;@pmmmwh/react-refresh-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const isDevelopment = process.env.SERVE;const plugins = [new CleanWebpackPlugin()];if (isDevelopment) { // react -element를 별도로 만드는 것이므로 개발 모드에서만 htmlplugin, refresh plugin 사용 plugins.push( new ReactRefreshWebpackPlugin(), new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) );}module.exports = { plugins,};1.4 TsconfigPathsPlugints에서 간단한 경로 설정을 위해 사용하는 플러그인이다.아래코드는 tsconfig.json을 참조하는 코드이다.const TsconfigPathsPlugin = require(&#39;tsconfig-paths-webpack-plugin&#39;);const tsConfigPath = path.resolve(__dirname, &#39;./tsconfig.json&#39;); resolve: { extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.js&#39;, &#39;.jsx&#39;], plugins: [ //ts를 위한 추가 플러그인 설정 new TsconfigPathsPlugin({ configFile: tsConfigPath, }), ], },tsconfig.json은 1편에서 본것과 똑같다.{ &quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;./dist/&quot;, &quot;sourceMap&quot;: true, &quot;noImplicitAny&quot;: true, &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es6&quot;, &quot;jsx&quot;: &quot;react&quot;, &quot;esModuleInterop&quot;: true, &quot;baseUrl&quot;: &quot;./src&quot; }, &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;**/*,spce.ts&quot;], &quot;include&quot;: [&quot;./src&quot;, &quot;index.d.ts&quot;]}2.전체 세팅(로더+플러그인)아래는 지금까지 참고한 블로그 글들과 유튜브 동영상등을 통해 필요한것을 추려 사용한 전체세팅이다추후에 부족한부분을 계속 채워넣으며 포스팅을 업그레이드 해야겠다..별도의 주석으로 설명을 달아놓았다.const path = require(&quot;path&quot;);// const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;); -&amp;gt; css를 별도로 추출할 예정이 없으므로 임의 삭제const ReactRefreshWebpackPlugin = require(&quot;@pmmmwh/react-refresh-webpack-plugin&quot;);const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const TsconfigPathsPlugin = require(&quot;tsconfig-paths-webpack-plugin&quot;);const tsConfigPath = path.resolve(__dirname, &quot;./tsconfig.json&quot;);const ReactRefreshTypeScript = require(&quot;react-refresh-typescript&quot;);const plugins = [new CleanWebpackPlugin()];const isDevelopment = process.env.SERVE;let mode = &quot;development&quot;;let target = &quot;web&quot;;if (process.env.NODE_ENV === &quot;production&quot;) { mode = &quot;production&quot;; target = &quot;browserslist&quot;;}if (isDevelopment) { // react -element를 별도로 만드는 것이므로 개발 모드에서만 htmlplugin, refresh plugin 사용 plugins.push( new ReactRefreshWebpackPlugin(), new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }) );}module.exports = { mode: mode, // 웹팩에서의 default모드는 해당 설정과 같이 해주지 않으면 default로 production이다. entry: &quot;./src/index.tsx&quot;, output: { path: path.resolve(__dirname, &quot;dist&quot;), // 깔끔한 웹팩 플러그인(clean-webpack-plugin)을 위해서는 output이 필요하다 filename: &quot;test.js&quot;, assetModuleFilename: &quot;images/[hash][ext][query]&quot;, // 모든 이미지들을 dist/images 하위 폴더로 넣기 위함 + 이미지가 변경될 시 브라우저 캐싱으로 인해 못알아차리는 경우가 있으므로 hash를 넣어주자 }, module: { rules: [ { test: /\\.(s[ac]|c)ss$/i, use: [ //웹팩 로더는 한 파일에 대해 여러가지가 실행되는데 배열의 뒤에서부터 앞으로 작동한다. &quot;style-loader&quot;, // js로 생성된 css를 styles 노드로 생성 &quot;css-loader&quot;, // css 를 js로 // &#39;postcss-loader&#39; //css파일 따로 extract하지 않을 것이므로 제외, &quot;sass-loader&quot;, // sass -&amp;gt; css로 컴파일 ], }, { test: /\\.(png|jpe?g|gif|svg)$/i, type: &quot;asset&quot;, //웹팩 5부터 url-loader, file-loader를 대신할 수 있게 되며 asset으로 설정 시 자동으로 base64로 컴파일(인라인번들 base 64, &amp;lt;= 8kb)하든지 images폴더로 넣어주든지 하게 해준다 /** * 큰 사이즈의 파일을 인라이닝 하고 싶으면 limit을 정해줄 수 도 있다 하단 parser 참고 */ parser: { dataUrlCondition: { maxSize: 30 * 1024, }, }, }, { test: /\\.[jt]sx?$/, exclude: /node_modules/, use: [ { loader: &quot;ts-loader&quot;, options: { getCustomTransformers: () =&amp;gt; ({ before: [isDevelopment &amp;amp;&amp;amp; ReactRefreshTypeScript()].filter( Boolean ), }), transpileOnly: isDevelopment, }, }, ], }, // 모든 &#39;.js&#39; 출력 파일은 &#39;source-map-loader&#39;에서 다시 처리한 소스 맵에서 존재. //dev setting일 시 변경되는 사항을 map을 통해서 빠르게 찾게 되는 것 + 이전 빌드 결과 존재시 더 빠른 build 가능 { test: [/\\.js?$/, /\\.ts?$/, /\\.jsx?$/, /\\.tsx?$/], enforce: &quot;pre&quot;, exclude: /node_modules/, use: [&quot;source-map-loader&quot;], }, { test: /\\.jsx?$/, exclude: /node_modules/, use: { //추가 설정 없으면 babelrc.를 참조하게 되어있다 //여기서는 개발모드일때와 빌드모드일때를 구분하기 위해 로직이 필요(react-refresh/babel)하므로 bable.config.js를 사용한다 loader: &quot;babel-loader&quot;, options: { cacheDirectory: true, //바벨이 recompile하는데 쓰이는 큰용량의 소스를 줄여줌 presets: [ &quot;@babel/preset-env&quot;, // in files only using JSX, -&amp;gt; TSX는 해당이 안되는것.. 같음 [&quot;@babel/preset-react&quot;, { runtime: &quot;automatic&quot; }], // Runtime automatic with React 17+ allows not importing React ], //하단 플러그인은 react-refresh-typescript에서 변경되는 ts를 바벨로더(js를 변환하는 용도이므로)가 못읽는 현상이 발생하기 때문 plugins: [isDevelopment &amp;amp;&amp;amp; &quot;react-refresh/babel&quot;], }, }, }, ], }, plugins: plugins, target: target, // Webpack의 출력물에서 디버깅을 하기위해 소스 맵 사용 devtool: &quot;source-map&quot;, resolve: { extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.jsx&quot;], plugins: [ //ts를 위한 추가 플러그인 설정 new TsconfigPathsPlugin({ configFile: tsConfigPath, }), ], }, //dev server 세팅 devServer: { static: &quot;./dist&quot;, //웹팩5부터 static으로 명칭 변경 port: 3000, hot: true, },}; webpack.config.js참고 Docs: Difference between esnext, es6, es2015 module targets npm &amp;gt; style-loader npm &amp;gt; url-loader 웹팩의 file-loader와 url-loader npm &amp;gt; ts-loader Talk to your React components with custom events github issue-dispatchEvent customEvent of web components not working webpack &amp;amp; ts image import https://github.com/pmmmwh/react-refresh-webpack-plugin/issues/176 react-refresh-webpack-plugin" }, { "title": "Webpack과 React를 사용하여 Custome Element 만들기[1 - 웹팩(로더)]", "url": "/posts/webpack/", "categories": "FE, Webpack", "tags": "Webpack", "date": "2021-09-13 12:33:00 +0900", "snippet": "왜 하게 되었냐면회사에서 기존 CRA로 만든 프로젝트를 커스텀엘리먼트화 하여 외부로 보내는 작업을 맡게 되었다.아직 구체적인 기획안과 협의안이 나오지 않은 상태이나 기본적으로 할 수 있는 방법을 알아야 하기 때문에 공부를 할 필요성이(드디어!!) 생겼다!샘플을 만들며 webpack,babel,loader 등의 세부 세팅을 공부하며 정리해보겠다 :)공식문서에 링크된 툴체인 직접만들기를 시작으로 다양한 자료들을 참고하며 상황에 맞춰 세팅을 진행했다.Webpack사용 이유웹팩을 사용하게 된 이유는 CRA로 이루어진 프로젝트이다보니 build 실행 시 여러개의 js파일이 생성되었고요구사항은 하나의 js를 통해 호스팅된 주소에서 원하는 이벤트를 발생시키는 것이었다.그래서 CRA를 뒤로하고 샘플부터 tsx로 만들어져있는 컴포넌트들을 하나의 js로 번들링할 계획을 가지고 시작하였다.세팅웹팩의 기능과 역할 그리고 세팅법에 관한 글은 하단에 무수히 많은 참고글을 보는것이 도움이 될것으로 판단되어 대부분 생략하고 진행하며새롭게 알게된 설정값이나 webpack5로 넘어오면서 변경된 부분들에 대해서는 언급하고 지나가겠다.1. 사용한 로더(Loader)1.1 Style1.1.1 sass-loadersa(c)ss를 css로 컴파일1.1.2 css-loader스타일 시트를 import 구문으로 불러오기 위해 css파일을 모듈로 바꾸는 역할import &quot;./style.css&quot;;1.1.3 style-loaderjs모듈화된 css 를 style 노드로 생성s(c)ass 와 css를 모두 커버할 생각이 었으므로 test에 적용된 정규식은 아래와 같고웹팩 로더는 use안에서 여러가지가 실행될 때 배열의 뒤에서 부터 앞으로 실행된다고 한다.그래서 sass-loader 를 통해 s(c)ass 를 css로 컴파일 하고 css-loader를 통해 css를 동적으로 생성할 수 있는 js로 변경해준 다음 style-loader를 통해 css를 style노드에 얹을 수 있게 만들어 주었다.PS. stlyed-components와 같은 css-in-js는 다른방식의 설정이 필요하다. npm 공식문서에 가면 볼 수 있다. { test: /\\.(s[ac]|c)ss$/i, use: [ //웹팩 로더는 한 파일에 대해 여러가지가 실행되는데 배열의 뒤에서부터 앞으로 작동한다. &#39;style-loader&#39;, // js로 생성된 css를 styles 노드로 생성 &#39;css-loader&#39;, // css 를 js로 // &#39;postcss-loader&#39; //css파일 따로 extract하지 않을 것이므로 제외, &#39;sass-loader&#39;, // sass -&amp;gt; css로 컴파일 ], },1.2 Files(asset)webpack 5 이상의 버전을 적용했기 때문에 type:asset으로 진행되어 기존의4점 이하의 버전대에서의 설정과 다소 상이하다.기존 url, file loader 사용시에 options에서 publicPath를 적용할 때 file과 url을 동일한 path를 적용해줬었다는 점만 기억하면 좋을 것 같다.또한 브라우저의 캐싱을 통해 파일이 업데이트 되어도 브라우저 내에서 반영되지 않는 현상을 피하기 위한 이름설정(hash)도 기억해놓으면 좋다.1.2.1 url-loaderbackground: url(“…”) 과 같은 url을 로드 해주는 것파일을 base64 URI로 변경해주는 역할1.2.2 file-loaderimport/require 로 선언되어 있는 파일또는 url을 지정된 output 으로 내보내주고 public URI의 파일로 반환해준다.소스코드에서 사용하는 모든 파일을 모듈로 사용하게끔 만들어주는 것,파일을 모듈형태로 지원하고 웹팩아웃풋에 파일을 옮겨주는 것이 file-loader이다.웹팩 5부터 url-loader, file-loader를 대신할 수 있게 되며 asset으로 설정 시 자동으로 base64로 컴파일(인라인번들 base 64, &amp;lt;= 8kb)하든지 images폴더로 넣어주든지 하게 해준다 { test: /\\.(png|jpe?g|gif|svg)$/i, type: &#39;asset&#39;, //웹팩 5부터 url-loader, file-loader를 대신할 수 있게 되며 asset으로 설정 시 자동으로 base64로 컴파일(인라인번들 base 64, &amp;lt;= 8kb)하든지 images폴더로 넣어주든지 하게 해준다 /** * 큰 사이즈의 파일을 인라이닝 하고 싶으면 limit을 정해줄 수 도 있다 하단 parser 참고 */ parser: { dataUrlCondition: { maxSize: 30 * 1024, }, }, },1.3 TypeScript1.3.1 ts-loadertypescript (es6) 를 javascript (es6) 로 변경해주는 것이다.TypeScript에 관한 옵션은 두가지가 있다. ts를 js로 컴파일링할 때 옵션은 tsconfig.json파일에서 진행한다. 웹팩으로 번들링 시 진행되는 ts-loader에 관한 옵션은 webpack.config.js 내의 해당 로더의 options에서 설정이 가능하다.첫번째로는 내가 설정한 tsconfig.json이다.자세한 설명은 주석으로 코드내에 남기는 것이 더 좋은것 같다.{ &quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;./dist/&quot;, //컴파일한 파일의 위치 지정 &quot;sourceMap&quot;: true, // 컴파일 후 source map 생성을 위해 true 설정 &amp;gt; dist에 **.map파일 생성됨 &quot;noImplicitAny&quot;: true, // any 타입인 경우 에러 발생 설정 &quot;module&quot;: &quot;commonjs&quot;, //컴파일을 위해 사용될 모듈 &quot;target&quot;: &quot;es6&quot;, //컴파일 버전 타겟 &quot;jsx&quot;: &quot;react&quot;, // jsx처리 &quot;esModuleInterop&quot;: true, //import 시 es6로 타겟팅하는 경우 컴파일 에러를 바로잡기 위한 설정 &quot;baseUrl&quot;: &quot;./src&quot; // base Directory 설정 }, &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;**/*.spce.ts&quot;, &quot;**/*.test.ts&quot;], &quot;include&quot;: [&quot;./src&quot;, &quot;index.d.ts&quot;]}두번째로는 내가 설정한 ts-loader에 관한 옵션이다.isDevelopment는 cross-env 모듈을 사용하여 스크립트 실행 시 개발모드에서는 true가 되는 변수이다.ts-loader의 경우 dev-server를 적용하기 위해 @pmmmwh/react-refresh-webpack-plugin를 사용하였으므로 getCustomTransformers에 컴파일링이 되기전 개발서버인 경우 ReactRefreshTypeScript가 한번 작동되는 것을 볼 수 있다.이렇게 설정해주지 않으면 초기 빌드가 잘되었다 하더라도 hot-server 상태에서 수정 후 저장 시 컴파일에서 깨져버린다.자세한 것은 하단 참고 또는 이 링크를 참고하면 좋다. { test: /\\.[jt]sx?$/, exclude: /node_modules/, use: [ { loader: &#39;ts-loader&#39;, options: { getCustomTransformers: () =&amp;gt; ({ before: [isDevelopment &amp;amp;&amp;amp; ReactRefreshTypeScript()].filter( Boolean ), }), transpileOnly: isDevelopment, }, }, ], },1.4 source-map-loadersource-map-loader 는 모든 js 엔트리에서 존재하는 소스맵을 추출해내는 역할을 한다.source-map은 빌드한 파일(번들링 완료된 파일)과 원본파일을 용이하게 연결시켜주는 파일이다.코드는 원본파일에서 수정하지만 변경되는 사항에 대해 빠르게 번들링 되어 적용되는 것에 한 몫을 하는 것이다.소스 맵을 이용해 빌드한 파일(번들링 완료된 파일)의 특정 부분이 원본 소스의 어떤 부분인지 확인하는 것이라고 하면 더 이해가 쉬울 것 같다.devtool에 관한 옵션을 찾아보면 이것저것 많은데 .. 고퀄리티의 소스맵을 만들어주는 옵션이 source-map이라는 옵션이다빌드시간이 좀 느리긴하다.{{ { test: [/\\.js?$/, /\\.ts?$/, /\\.jsx?$/, /\\.tsx?$/], enforce: &#39;pre&#39;, exclude: /node_modules/, //node_modules는 제외 use: [&#39;source-map-loader&#39;], },}, // Webpack의 출력물에서 디버깅을 하기위해 소스 맵 사용을 위한 옵션중 source-map 사용 devtool: &#39;source-map&#39;, }1.5 babel-loaderjs(es6)를 js(es5)로 변환해주므로 다양한 브라우저에서 es6가 잘 돌아가도록 도움을 준다.원래 별도의 bable.config.js파일로 관리를 하려 하였으나 당장 필요한 설정도 몇개 없어서 웹팩안에 해당 preset에 관한 설정을 집어 넣었다.여기에서도 개발서버 설정을 위해 개발모드 인 경우에만 플러그인 으로 서 react-refresh/babel이라는 별도의 플러그인 을 사용하도록 세팅되어있다. { test: /\\.jsx?$/, exclude: /node_modules/, use: { //추가 설정 없으면 babelrc.를 참조하게 되어있다 loader: &#39;babel-loader&#39;, options: { cacheDirectory: true, //바벨이 recompile하는데 쓰이는 큰용량의 소스를 줄여줌 presets: [ &#39;@babel/preset-env&#39;, // in files only using JSX, -&amp;gt; TSX는 해당이 안되는것.. 같음 [&#39;@babel/preset-react&#39;, { runtime: &#39;automatic&#39; }], // Runtime automatic with React 17+ allows not importing React ], //하단 플러그인은 react-refresh-typescript에서 변경되는 ts를 바벨로더(js를 변환하는 용도이므로)가 못읽는 현상이 발생하기 때문 plugins: [isDevelopment &amp;amp;&amp;amp; &#39;react-refresh/babel&#39;], }, }, },참고 Webpack 5 Full Project Setup 리액트 &amp;amp; 웹팩 typescript &amp;gt; esModuleInterop Setting up Webpack 5 with React and Babel from scratch [2021] 자주 사용하는 로더,웹팩 기본편 by 김정환 medium blog tutorials/react-&amp;amp;-webpack" }, { "title": "정규표현식", "url": "/posts/RegEx/", "categories": "BE, RegEx", "tags": "RegEx", "date": "2021-09-08 12:33:00 +0900", "snippet": "참고!이 포스팅은 드림코딩 엘리 유튜브 채널의** 정규표현식 , 더이상 미루지 말자 🤩** 포스팅을 보고 개인공부를 위해 정리한 내용입니다 :)추가적으로 참고한 포스팅은 아래와 같습니다모든 저작권은 드림코딩 by엘리에게 있습니다. 공부를 위한 참고용 포스트 입니다.정규표현식은 텍스트에서 필요한 형태의 패턴을 찾을 때 주로 사용이 된다.Email, Pw의 유효성 검사에서도 사용된다.slash를 이용하여 정규표현식을 나타내고 그 안에 패턴을 적고 flag를 이용한 옵션을 준다./regex?/i1. Groups &amp;amp; Ranges| : 또는() : 그룹[]: 문자셋, 괄호안의 어떤 문자 든[^]: 부정 문자셋, 괄호안의 어떤 문자가 아닐 때(?:) 찾지만 기억하지는 않음 -&amp;gt; 쓰면 그룹이 지정되는게 풀린다1.1 그룹을 이용한 찾는 방식그룹을 이용한 찾는 방식1.2 (?:)를 이용한 방식1.3 부정문자셋과 대괄호 사용a~z와 A-Z와 0~9에 해당하는 것을 제외한 모든 것을 찾게됨.2.Quantifiers?: 없거나 있거나*: 없거나 있거나 많거나{n}: n번 반복{min, }: 최소{min,max}: 최소, 그리고 최대2.1 ?를 사용-&amp;gt; a 다음 y가 존재하거나 존재하지 않거나의 케이스를 찾아 줌2.2 {min, max?} 활용-&amp;gt; gra다음 최소 두가지 최대 3가지가 나오고 y가 들어가는 케이스에 대해 찾음 Boundary-type\\b: 단어경계\\B: 단어경계가 아님^: 문장의 시작$: 문장의 끝3.1 $를 활용-&amp;gt; 문장의 끝에 해당하는 Ya를 검색하게 됨. Character classes\\:특수문자가 아닌 문자. 어떤 글자(줄바꿈 문자 제외)\\d: digit 숫자\\w: word 문자\\s: space공백\\S: space공백 아님4.1 특수문자 ‘[]’를 찾기위해 ‘&#39; 를 활용하는 방법 휴대폰 번호 찾기5.1 혼자시도휴대폰 번호라서 010 은 박아놓고 들어올 케이스들이 -, ,.뿐이어서 그냥 수량으로 해결했다 ..-&amp;gt; 가장 쉬운 것 부터 접근하라고 하셨다1. \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d2. \\d{2,3}-\\d{3}-\\d{4}3. \\d{2,3}[- .]\\d{3}[- .]\\d{4}5.2 이메일 찾기5.2.1 혼자시도최소값만 지정해주고 다 붙여버렸다.실제로는 이렇게 쓰면 큰일날듯 ㅎㅅㅎ..5.2.2 쉽게쉽게 .. + 를 활용하기6.youtube에서 특정 id값만 찾아내기?:를 활용하여 제외케이스를 만들어서 그룹에서 제외하기 숫자 콤마찍기const numb = (x) =&amp;gt; { let regEx = /\\B(?=(\\d{3})+(?!\\d))/g; let madeString = String(x).replace(regEx, &quot;,&quot;); return madeString;};console.log(numb(1000)); 연습용 사이트regexone 참고정규표현식, 더 이상 미루지말자 드림코딩by엘리github 드림코딩by엘리연습용 사이트 (regexr.com)" }, { "title": "Cors와 Preflight", "url": "/posts/Cors-Preflight/", "categories": "BE, Resource", "tags": "Cors, Prefilght", "date": "2021-06-12 12:33:00 +0900", "snippet": "참고!이 포스팅은 우아한Tech 유튜브 채널의** [10분 테코톡] 🌳 나봄의 CORS** 포스팅을 보고 개인공부를 위해 정리한 내용입니다 :)추가적으로 참고한 포스팅은 아래와 같습니다 다른 도메인간 쿠키 전송하기(axios와 express 예제)CORS는 왜 존재하나존재의 이유를 알기 위해 필요한 몇가지 개념과 예시를 보자SOP(Same Origin Policy)다른 출처의 리소스를 사용하는 것에 제한을 거는 보안 방식이다.SOP를 사용해야하는 예시 어떤 유저가 Facebook에 로그인을 하고 토큰을 받아 로그인 과정을 완료햇다. 유저는 로그인한 상태로 재미있는 메일을 해커(http://hacker.com)로 부터 받았다(너무 재미있어서 클릭을 안할 수 없을 정도) 해커는 재미있는 메일 안에 임의로 페이스북(http://facebook.com)에 무엇인가를 작성할 수 있게 해버리는 script코드를 적어 보냈다. 이때 페이스북에 유저의 토큰을 가지고 해커의 출처(origin)을 통해 글을 작성하려고 하게 된다. 이때 SOP 정책에 의해 요청을 확인하고 다른 출처(origin)을 가지게 되므로 페이스북에서 자신의 출처와 다른출처를 가지므로 SOP정책에 의해 해당 요청을 거부하게 된다. 그래서 CORS란 ?Cross-Origin Resource Sharing으로서 다른 출처(origin)의 자원을 공유하는 것이다.추가 Http 헤더를 사용하여, 한 출처에서 실행 중인 웹 어플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제이다.CORS의 접근제어 시나리오1. 단순 요청(Simple Request)Preflight의 요청없이 바로 서버로 요청을 날리게 된다.GET, POST, HEAD 메서드가 들어있고 Content-Type이 들어있다.2. 프리플라이트 요청(Prefilght Request)prefilght란?출처:https://livebook.manning.com/덧글 중에 너무 잘 설명을 해놓으신게 있어 인용을 해보겠다..(따라치는거지 뭐..) CROS spec이 생기기 이전에 만들어진 서버들은 브라우저의 SOP Request만 가능하다는 가정하에 만들어졌다. 그런데, cross-site request가 CORS로 인해 가능해졌기 때문에 이러한 서버들은 cross-site request에 대한 보안 메커니즘(security mechanism)이 없다보니 보안적으로 문제가 생길 수 있었다. 이런 보안적인 문제들을 보호하기 위해 CORS spec에다가 preflight request를 포함하여 prefilght request를 통해 서버가 CORS를 인식하고 핸들링할 수 있는지 먼저 확인을 하게 한 뒤 , CORS를 인식하지 못하는 서버들을 보호하게 된다. 만약 preflight request가 서버로 전송을 하였을 때 CORS를 인식하지 못하는 서버라면 제대로 된 응답(response)를 보내지 못하게 되고 그렇게 되면 실제 client로 부터의 요청(request)도 전송되지 않게 되어 preflight 가 cross-origin 요청(request)에 대비 되지 않은 서버를 보호해주게 된다. 3. 인증정보 포함 요청(Credential Request)인증관련 헤더를 포함할때 사용하는 요청이다. 클라이언트 측에서는 credentials: “include” (이외에도 same origin 등의 옵션이 더 있다.) origin이 다른 http 통신에서는 request header에 쿠키가 자동으로 들어가지 않는다. 다른 출처의 경우 로그인 유지를 위한 쿠키가 서로 전송되지 않는 문제가 있어 해당 옵션을 주는 것으로 사용하는 것 같다.설정은 서버측에서는 Acess-Control-Allow-Credential: true이때 와일드카드(*)는 안된다.4. CORS 해결하기! 프론트 프록시 서버설정(개발 환경)개발 환경에서 api 요청을 하는 target을 동일한 포트로 설정하고 개발하기 직접 헤더에 설정해주기 스프링부트를 이용하기(?)-&amp;gt; 나봄님은 spring에 맞춰서 데코레이터에 origin 값을 설정해주고 CORS를 해결하신 것을 보여주신 다음 configuration 파일을 따로 만들어서 origins와 관련된 메서드를 통해 해결하셨다. 나는 node를 사용하고 있어서 이부분은 node에 맞춰서 다시 적어보겠다 .. 5. Node에 맞춰서 해결해보자.노드에서는 cors 모듈을 import하여 사용하면 편하게 할 수 있는데 use메서드를 통해 미들웨어로 적용해주면 된다.내가 작성한 코드는 origin을 request가 들어오는 origin과 동일하게 사용하고 있다.(사실 상 wild card이다)그리고 credential true설정을 통해 프론트에서는 헤더에 withCredential: true를 헤더에 담아 사용하고 있다.백엔드 코드그렇다면 cors 모듈에 대해 조금 더 파보자.출처:Express cors middleware캡쳐본의 설명에도 있듯이 origin 옵션을 통해 실제로 필요한 출처(origin)만 허용해줄 수도 있다." } ]
